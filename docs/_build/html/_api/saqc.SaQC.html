
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>SaQC &#8212; SaQC 2.0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/nature.css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../_static/tabs.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.1/dist/embed-amd.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="shortcut icon" href="../_static/SaQCLogoSmall.png"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="SaQC" href="../modules/SaQCCore.html" />
    <link rel="prev" title="Flags" href="saqc.Flags.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../modules/SaQCCore.html" title="SaQC"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="saqc.Flags.html" title="Flags"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">SaQC 2.0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../modules/SaQC.html" accesskey="U">SaQC</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">SaQC</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <p><a class="reference external" href="https://www.ufz.de/"><img alt="ufzLogo" src="../_images/UFZLogo.png" style="width: 40%;" /></a> <a class="reference external" href="https://www.ufz.de/index.php?de=45348"><img alt="rdmLogo" class="align-right" src="../_images/RDMLogo.png" style="width: 22%;" /></a></p>
<section id="saqc">
<h1>SaQC<a class="headerlink" href="#saqc" title="Permalink to this headline">¶</a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="saqc.SaQC">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">SaQC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scheme</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'float'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/saqc/core/core.html#SaQC"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#saqc.SaQC" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">saqc.core.modules.FunctionsMixin</span></code></p>
<p class="rubric">Attributes Summary</p>
<table class="autosummary longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#saqc.SaQC.attrs" title="saqc.SaQC.attrs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">attrs</span></code></a></p></td>
<td><p>Dictionary of global attributes of this dataset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#saqc.SaQC.data" title="saqc.SaQC.data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">data</span></code></a></p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">rtype</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">MutableMapping</span></code></p>
</dd>
</dl>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#saqc.SaQC.flags" title="saqc.SaQC.flags"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flags</span></code></a></p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">rtype</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">MutableMapping</span></code></p>
</dd>
</dl>
</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Methods Summary</p>
<table class="autosummary longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#saqc.SaQC.assignChangePointCluster" title="saqc.SaQC.assignChangePointCluster"><code class="xref py py-obj docutils literal notranslate"><span class="pre">assignChangePointCluster</span></code></a>(field, stat_func, ...)</p></td>
<td><p>Label data where it changes significantly.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#saqc.SaQC.assignKNNScore" title="saqc.SaQC.assignKNNScore"><code class="xref py py-obj docutils literal notranslate"><span class="pre">assignKNNScore</span></code></a>(field, target[, n, func, ...])</p></td>
<td><p>TODO: docstring need a rework Score datapoints by an aggregation of the dictances to their k nearest neighbors.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#saqc.SaQC.assignRegimeAnomaly" title="saqc.SaQC.assignRegimeAnomaly"><code class="xref py py-obj docutils literal notranslate"><span class="pre">assignRegimeAnomaly</span></code></a>(field, cluster_field, spread)</p></td>
<td><p>A function to detect values belonging to an anomalous regime regarding modelling regimes of field.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#saqc.SaQC.calculatePolynomialResiduals" title="saqc.SaQC.calculatePolynomialResiduals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculatePolynomialResiduals</span></code></a>(field, window, ...)</p></td>
<td><p>Fits a polynomial model to the data and calculate the residuals.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#saqc.SaQC.calculateRollingResiduals" title="saqc.SaQC.calculateRollingResiduals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculateRollingResiduals</span></code></a>(field, window[, ...])</p></td>
<td><p>Calculate the diff of a rolling-window function and the data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#saqc.SaQC.clearFlags" title="saqc.SaQC.clearFlags"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clearFlags</span></code></a>(field, **kwargs)</p></td>
<td><p>Set whole column to UNFLAGGED.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#saqc.SaQC.concatFlags" title="saqc.SaQC.concatFlags"><code class="xref py py-obj docutils literal notranslate"><span class="pre">concatFlags</span></code></a>(field, target[, method, freq, ...])</p></td>
<td><p>The Function appends flags history of <code class="docutils literal notranslate"><span class="pre">fields</span></code> to flags history of <code class="docutils literal notranslate"><span class="pre">target</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#saqc.SaQC.copy" title="saqc.SaQC.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>([deep])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#saqc.SaQC.copyField" title="saqc.SaQC.copyField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copyField</span></code></a>(field, target[, overwrite])</p></td>
<td><p>Copy data and flags to a new name (preserve flags history).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#saqc.SaQC.correctDrift" title="saqc.SaQC.correctDrift"><code class="xref py py-obj docutils literal notranslate"><span class="pre">correctDrift</span></code></a>(field, maintenance_field, model)</p></td>
<td><p>The function corrects drifting behavior.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#saqc.SaQC.correctOffset" title="saqc.SaQC.correctOffset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">correctOffset</span></code></a>(field, max_jump, spread, ...)</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">type field</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></p>
</dd>
</dl>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#saqc.SaQC.correctRegimeAnomaly" title="saqc.SaQC.correctRegimeAnomaly"><code class="xref py py-obj docutils literal notranslate"><span class="pre">correctRegimeAnomaly</span></code></a>(field, cluster_field, model)</p></td>
<td><p>Function fits the passed model to the different regimes in data[field] and tries to correct those values, that have assigned a negative label by data[cluster_field].</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#saqc.SaQC.dropField" title="saqc.SaQC.dropField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dropField</span></code></a>(field, **kwargs)</p></td>
<td><p>Drops field from the data and flags.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#saqc.SaQC.fitPolynomial" title="saqc.SaQC.fitPolynomial"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fitPolynomial</span></code></a>(field, window, order[, ...])</p></td>
<td><p>Fits a polynomial model to the data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#saqc.SaQC.flagByGrubbs" title="saqc.SaQC.flagByGrubbs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flagByGrubbs</span></code></a>(field, window[, alpha, ...])</p></td>
<td><p>The function flags values that are regarded outliers due to the grubbs test.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#saqc.SaQC.flagByStatLowPass" title="saqc.SaQC.flagByStatLowPass"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flagByStatLowPass</span></code></a>(field, func, window, thresh)</p></td>
<td><p>Flag <em>chunks</em> of length, <cite>window</cite>:</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#saqc.SaQC.flagByStray" title="saqc.SaQC.flagByStray"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flagByStray</span></code></a>(field[, window, min_periods, ...])</p></td>
<td><p>Flag outliers in 1-dimensional (score) data with the STRAY Algorithm.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#saqc.SaQC.flagByVariance" title="saqc.SaQC.flagByVariance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flagByVariance</span></code></a>(field, window, thresh[, ...])</p></td>
<td><p>Flag low-variance data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#saqc.SaQC.flagChangePoints" title="saqc.SaQC.flagChangePoints"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flagChangePoints</span></code></a>(field, stat_func, ...[, ...])</p></td>
<td><p>Flag data where it significantly changes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#saqc.SaQC.flagConstants" title="saqc.SaQC.flagConstants"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flagConstants</span></code></a>(field, thresh, window[, flag])</p></td>
<td><p>Flag constant data values.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#saqc.SaQC.flagCrossStatistics" title="saqc.SaQC.flagCrossStatistics"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flagCrossStatistics</span></code></a>(field, thresh[, method, ...])</p></td>
<td><p>Function checks for outliers relatively to the &quot;horizontal&quot; input data axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#saqc.SaQC.flagDriftFromNorm" title="saqc.SaQC.flagDriftFromNorm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flagDriftFromNorm</span></code></a>(field, freq, spread[, ...])</p></td>
<td><p>Flags data that deviates from an avarage data course.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#saqc.SaQC.flagDriftFromReference" title="saqc.SaQC.flagDriftFromReference"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flagDriftFromReference</span></code></a>(field, reference, ...)</p></td>
<td><p>Flags data that deviates from a reference course.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#saqc.SaQC.flagDummy" title="saqc.SaQC.flagDummy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flagDummy</span></code></a>(field, **kwargs)</p></td>
<td><p>Set whole column to a flag value.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#saqc.SaQC.flagGeneric" title="saqc.SaQC.flagGeneric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flagGeneric</span></code></a>(field, func[, target, flag, dfilter])</p></td>
<td><p>Flag data with user defined functions.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#saqc.SaQC.flagIsolated" title="saqc.SaQC.flagIsolated"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flagIsolated</span></code></a>(field, gap_window, group_window)</p></td>
<td><p>Find and flag temporal isolated groups of data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#saqc.SaQC.flagJumps" title="saqc.SaQC.flagJumps"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flagJumps</span></code></a>(field, thresh, window[, ...])</p></td>
<td><p>Flag jumps and drops in data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#saqc.SaQC.flagMAD" title="saqc.SaQC.flagMAD"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flagMAD</span></code></a>(field, window[, z, flag])</p></td>
<td><p>The function represents an implementation of the modyfied Z-score outlier detection method.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#saqc.SaQC.flagMVScores" title="saqc.SaQC.flagMVScores"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flagMVScores</span></code></a>(field[, trafo, alpha, n, func, ...])</p></td>
<td><p>The algorithm implements a 3-step outlier detection procedure for simultaneously flagging of higher dimensional data (dimensions &gt; 3).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#saqc.SaQC.flagManual" title="saqc.SaQC.flagManual"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flagManual</span></code></a>(field, mdata[, method, mformat, ...])</p></td>
<td><p>Flag data by given, &quot;manually generated&quot; data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#saqc.SaQC.flagMissing" title="saqc.SaQC.flagMissing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flagMissing</span></code></a>(field[, flag, dfilter])</p></td>
<td><p>Flag NaNs in data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#saqc.SaQC.flagOffset" title="saqc.SaQC.flagOffset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flagOffset</span></code></a>(field, tolerance, window[, ...])</p></td>
<td><p>A basic outlier test that works on regularly and irregularly sampled data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#saqc.SaQC.flagPatternByDTW" title="saqc.SaQC.flagPatternByDTW"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flagPatternByDTW</span></code></a>(field, reference[, ...])</p></td>
<td><p>Pattern Recognition via Dynamic Time Warping.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#saqc.SaQC.flagRaise" title="saqc.SaQC.flagRaise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flagRaise</span></code></a>(field, thresh, raise_window, freq)</p></td>
<td><p>The function flags raises and drops in value courses, that exceed a certain threshold within a certain timespan.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#saqc.SaQC.flagRange" title="saqc.SaQC.flagRange"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flagRange</span></code></a>(field[, min, max, flag])</p></td>
<td><p>Function flags values not covered by the closed interval [<cite>min</cite>, <cite>max</cite>].</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#saqc.SaQC.flagRegimeAnomaly" title="saqc.SaQC.flagRegimeAnomaly"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flagRegimeAnomaly</span></code></a>(field, cluster_field, spread)</p></td>
<td><p>Flags anomalous regimes regarding to modelling regimes of field.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#saqc.SaQC.flagUnflagged" title="saqc.SaQC.flagUnflagged"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flagUnflagged</span></code></a>(field[, flag])</p></td>
<td><p>Function sets a flag at all unflagged positions.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#saqc.SaQC.forceFlags" title="saqc.SaQC.forceFlags"><code class="xref py py-obj docutils literal notranslate"><span class="pre">forceFlags</span></code></a>(field[, flag])</p></td>
<td><p>Set whole column to a flag value.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#saqc.SaQC.interpolate" title="saqc.SaQC.interpolate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolate</span></code></a>(field, freq, method[, order])</p></td>
<td><p>A method to &quot;regularize&quot; data by interpolating the data at regular timestamp.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#saqc.SaQC.interpolateByRolling" title="saqc.SaQC.interpolateByRolling"><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolateByRolling</span></code></a>(field, window[, func, ...])</p></td>
<td><p>Interpolates nan-values in the data by assigning them the aggregation result of the window surrounding them.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#saqc.SaQC.interpolateIndex" title="saqc.SaQC.interpolateIndex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolateIndex</span></code></a>(field, freq, method[, ...])</p></td>
<td><p>Function to interpolate the data at regular (equidistant) timestamps (or Grid points).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#saqc.SaQC.interpolateInvalid" title="saqc.SaQC.interpolateInvalid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolateInvalid</span></code></a>(field, method[, order, ...])</p></td>
<td><p>Function to interpolate nan values in the data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#saqc.SaQC.linear" title="saqc.SaQC.linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linear</span></code></a>(field, freq, **kwargs)</p></td>
<td><p>A method to &quot;regularize&quot; data by interpolating linearly the data at regular timestamp.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#saqc.SaQC.plot" title="saqc.SaQC.plot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot</span></code></a>(field[, path, max_gap, history, ...])</p></td>
<td><p>Plot data and flags or store plot to file.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#saqc.SaQC.processGeneric" title="saqc.SaQC.processGeneric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">processGeneric</span></code></a>(field, func[, target, dfilter])</p></td>
<td><p>Generate/process data with user defined functions.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#saqc.SaQC.propagateFlags" title="saqc.SaQC.propagateFlags"><code class="xref py py-obj docutils literal notranslate"><span class="pre">propagateFlags</span></code></a>(field, window[, method, ...])</p></td>
<td><p>Flag values before or after flags set by the last test.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#saqc.SaQC.renameField" title="saqc.SaQC.renameField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">renameField</span></code></a>(field, new_name, **kwargs)</p></td>
<td><p>Rename field in data and flags.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#saqc.SaQC.resample" title="saqc.SaQC.resample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resample</span></code></a>(field, freq[, func, method, maxna, ...])</p></td>
<td><p>Function to resample the data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#saqc.SaQC.roll" title="saqc.SaQC.roll"><code class="xref py py-obj docutils literal notranslate"><span class="pre">roll</span></code></a>(field, window[, func, min_periods, center])</p></td>
<td><p>Calculate a rolling-window function on the data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#saqc.SaQC.selectTime" title="saqc.SaQC.selectTime"><code class="xref py py-obj docutils literal notranslate"><span class="pre">selectTime</span></code></a>(field, mode[, selection_field, ...])</p></td>
<td><p>Realizes masking within saqc.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#saqc.SaQC.shift" title="saqc.SaQC.shift"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shift</span></code></a>(field, freq[, method, freq_check])</p></td>
<td><p>Function to shift data and flags to a regular (equidistant) timestamp grid, according to <code class="docutils literal notranslate"><span class="pre">method</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#saqc.SaQC.transferFlags" title="saqc.SaQC.transferFlags"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transferFlags</span></code></a>(field, target, **kwargs)</p></td>
<td><p>Transfer Flags of one variable to another.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#saqc.SaQC.transform" title="saqc.SaQC.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>(field, func[, freq])</p></td>
<td><p>Function to transform data columns with a transformation that maps series onto series of the same length.</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes Documentation</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="saqc.SaQC.attrs">
<span class="sig-name descname"><span class="pre">attrs</span></span><a class="headerlink" href="#saqc.SaQC.attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Dictionary of global attributes of this dataset.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="saqc.SaQC.data">
<span class="sig-name descname"><span class="pre">data</span></span><a class="headerlink" href="#saqc.SaQC.data" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">MutableMapping</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="saqc.SaQC.flags">
<span class="sig-name descname"><span class="pre">flags</span></span><a class="headerlink" href="#saqc.SaQC.flags" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">MutableMapping</span></code></p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Methods Documentation</p>
<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.assignChangePointCluster">
<span class="sig-name descname"><span class="pre">assignChangePointCluster</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stat_func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thresh_func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_periods</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">closed='both'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduce_window=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduce_func=&lt;function</span> <span class="pre">ChangePoints.&lt;lambda&gt;&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_by_resids=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.assignChangePointCluster" title="Permalink to this definition">¶</a></dt>
<dd><p>Label data where it changes significantly.</p>
<p>The labels will be stored in data. Unless <cite>target</cite> is given the labels will
overwrite the data in <cite>field</cite>. The flags will always set to <cite>UNFLAGGED</cite>.</p>
<p>Assigns label to the data, aiming to reflect continuous regimes of the processes
the data is assumed to be generated by. The regime change points detection is
based on a sliding window search.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>field</strong> (<em>str</em>) – The reference variable, the deviation from wich determines the flagging.</p>
</dd>
</dl>
<dl>
<dt>stat_func<span class="classifier">Callable[[numpy.array, numpy.array], float]</span></dt><dd><p>A function that assigns a value to every twin window. Left window content will
be passed to first variable,
right window content will be passed to the second.</p>
</dd>
<dt>thresh_func<span class="classifier">Callable[numpy.array, numpy.array], float]</span></dt><dd><p>A function that determines the value level, exceeding wich qualifies a
timestamps func func value as denoting a changepoint.</p>
</dd>
<dt>window<span class="classifier">str, tuple of string</span></dt><dd><p>Size of the rolling windows the calculation is performed in. If it is a single
frequency offset, it applies for the backward- and the forward-facing window.</p>
<p>If two offsets (as a tuple) is passed the first defines the size of the
backward facing window, the second the size of the forward facing window.</p>
</dd>
<dt>min_periods<span class="classifier">int or tuple of int</span></dt><dd><p>Minimum number of observations in a window required to perform the changepoint
test. If it is a tuple of two int, the first refer to the backward-,
the second to the forward-facing window.</p>
</dd>
<dt>closed<span class="classifier">{‘right’, ‘left’, ‘both’, ‘neither’}, default ‘both’</span></dt><dd><p>Determines the closure of the sliding windows.</p>
</dd>
<dt>reduce_window<span class="classifier">{None, str}, default None</span></dt><dd><p>The sliding window search method is not an exact CP search method and usually
there wont be detected a single changepoint, but a “region” of change around
a changepoint. If <cite>reduce_window</cite> is given, for every window of size
<cite>reduce_window</cite>, there will be selected the value with index <cite>reduce_func(x,
y)</cite> and the others will be dropped. If <cite>reduce_window</cite> is None, the reduction
window size equals the twin window size, the changepoints have been detected
with.</p>
</dd>
<dt>reduce_func<span class="classifier">callable, default lambda x,y: x.argmax()</span></dt><dd><p>A function that must return an index value upon input of two arrays x and y.
First input parameter will hold the result from the stat_func evaluation for
every reduction window. Second input parameter holds the result from the
thresh_func evaluation. The default reduction function just selects the value
that maximizes the stat_func.</p>
</dd>
<dt>model_by_resids<span class="classifier">bool, default False</span></dt><dd><p>If True, the results of <cite>stat_funcs</cite> are written, otherwise the regime labels.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.assignKNNScore">
<span class="sig-name descname"><span class="pre">assignKNNScore</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n=10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func=&lt;function</span> <span class="pre">sum&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq=inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_periods=2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method='ball_tree'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric='minkowski'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p=2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.assignKNNScore" title="Permalink to this definition">¶</a></dt>
<dd><p>TODO: docstring need a rework
Score datapoints by an aggregation of the dictances to their k nearest neighbors.</p>
<p>The function is a wrapper around the NearestNeighbors method from pythons sklearn library (See reference [1]).</p>
<p>The steps taken to calculate the scores are as follows:</p>
<ol class="arabic simple">
<li><p>All the timeseries, given through <code class="docutils literal notranslate"><span class="pre">field</span></code>, are combined to one feature space by an <em>inner</em> join on their
date time indexes. thus, only samples, that share timestamps across all <code class="docutils literal notranslate"><span class="pre">field</span></code> will be included in the
feature space.</p></li>
<li><p>Any datapoint/sample, where one ore more of the features is invalid (=np.nan) will get excluded.</p></li>
<li><p>For every data point, the distance to its <cite>n</cite> nearest neighbors is calculated by applying the
metric <cite>metric</cite> at grade <cite>p</cite> onto the feature space. The defaults lead to the euclidian to be applied.
If <cite>radius</cite> is not None, it sets the upper bound of distance for a neighbor to be considered one of the
<cite>n</cite> nearest neighbors. Furthermore, the <cite>freq</cite> argument determines wich samples can be
included into a datapoints nearest neighbors list, by segmenting the data into chunks of specified temporal
extension and feeding that chunks to the kNN algorithm seperatly.</p></li>
<li><p>For every datapoint, the calculated nearest neighbors distances get aggregated to a score, by the function
passed to <cite>func</cite>. The default, <code class="docutils literal notranslate"><span class="pre">sum</span></code> obviously just sums up the distances.</p></li>
<li><p>The resulting timeseries of scores gets assigned to the field target.</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> (<em>list of str</em>) – input variable names.</p></li>
<li><p><strong>target</strong> (<em>str</em><em>, </em><em>default &quot;kNNscores&quot;</em>) – A new Column name, where the result is stored.</p></li>
<li><p><strong>n</strong> (<em>int</em><em>, </em><em>default 10</em>) – The number of nearest neighbors to which the distance is comprised in every datapoints scoring calculation.</p></li>
<li><p><strong>func</strong> (<em>Callable</em><em>[</em><em>numpy.array</em><em>, </em><em>float</em><em>]</em><em>, </em><em>default np.sum</em>) – A function that assigns a score to every one dimensional array, containing the distances
to every datapoints <cite>n</cite> nearest neighbors.</p></li>
<li><p><strong>freq</strong> (<em>{np.inf</em><em>, </em><em>float</em><em>, </em><em>str}</em><em>, </em><em>default np.inf</em>) – <p>Determines the segmentation of the data into partitions, the kNN algorithm is
applied onto individually.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">np.inf</span></code>: Apply Scoring on whole data set at once</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> &gt; 0 : Apply scoring on successive data chunks of periods length <code class="docutils literal notranslate"><span class="pre">x</span></code></p></li>
<li><p>Offset String : Apply scoring on successive partitions of temporal extension matching the passed offset
string</p></li>
</ul>
</p></li>
<li><p><strong>min_periods</strong> (<em>int</em><em>, </em><em>default 2</em>) – The minimum number of periods that have to be present in a partition for the kNN scoring
to be applied. If the number of periods present is below <cite>min_periods</cite>, the score for the
datapoints in that partition will be np.nan.</p></li>
<li><p><strong>method</strong> (<em>{'ball_tree'</em><em>, </em><em>'kd_tree'</em><em>, </em><em>'brute'</em><em>, </em><em>'auto'}</em><em>, </em><em>default 'ball_tree'</em>) – The search algorithm to find each datapoints k nearest neighbors.
The keyword just gets passed on to the underlying sklearn method.
See reference [1] for more information on the algorithm.</p></li>
<li><p><strong>metric</strong> (<em>str</em><em>, </em><em>default 'minkowski'</em>) – The metric the distances to any datapoints neighbors is computed with. The default of <cite>metric</cite>
together with the default of <cite>p</cite> result in the euclidian to be applied.
The keyword just gets passed on to the underlying sklearn method.
See reference [1] for more information on the algorithm.</p></li>
<li><p><strong>p</strong> (<em>int</em><em>, </em><em>default 2</em>) – The grade of the metrice specified by parameter <cite>metric</cite>.
The keyword just gets passed on to the underlying sklearn method.
See reference [1] for more information on the algorithm.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
<p class="rubric">References</p>
<p>[1] <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.NearestNeighbors.html">https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.NearestNeighbors.html</a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.assignRegimeAnomaly">
<span class="sig-name descname"><span class="pre">assignRegimeAnomaly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cluster_field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spread</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method='single'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric=&lt;function</span> <span class="pre">Drift.&lt;lambda&gt;&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frac=0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.assignRegimeAnomaly" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to detect values belonging to an anomalous regime regarding modelling
regimes of field.</p>
<p>The function changes the value of the regime cluster labels to be negative.
“Normality” is determined in terms of a maximum spreading distance, regimes must
not exceed in respect to a certain metric and linkage method. In addition,
only a range of regimes is considered “normal”, if it models more then <cite>frac</cite>
percentage of the valid samples in “field”. Note, that you must detect the regime
changepoints prior to calling this function. (They are expected to be stored
parameter <cite>cluster_field</cite>.)</p>
<p>Note, that it is possible to perform hypothesis tests for regime equality by
passing the metric a function for p-value calculation and selecting linkage
method “complete”.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> (<em>str</em>) – Name of the column to process</p></li>
<li><p><strong>cluster_field</strong> (<em>str</em>) – Column in data, holding the cluster labels for the samples in field.
(has to be indexed equal to field)</p></li>
<li><p><strong>spread</strong> (<em>float</em>) – A threshold denoting the value level, up to wich clusters a agglomerated.</p></li>
<li><p><strong>method</strong> (<em>{&quot;single&quot;</em><em>, </em><em>&quot;complete&quot;</em><em>, </em><em>&quot;average&quot;</em><em>, </em><em>&quot;weighted&quot;</em><em>, </em><em>&quot;centroid&quot;</em><em>, </em><em>&quot;median&quot;</em><em>, </em><em>&quot;ward&quot;}</em><em>, </em><em>default &quot;single&quot;</em>) – The linkage method for hierarchical (agglomerative) clustering of the variables.</p></li>
<li><p><strong>metric</strong> (<em>Callable</em><em>, </em><em>default lambda x</em><em>,</em><em>y: np.abs</em><em>(</em><em>np.nanmean</em><em>(</em><em>x</em><em>) </em><em>- np.nanmean</em><em>(</em><em>y</em><em>)</em><em>)</em>) – A metric function for calculating the dissimilarity between 2 regimes.
Defaults to the difference in mean.</p></li>
<li><p><strong>frac</strong> (<em>float</em>) – Has to be in [0,1]. Determines the minimum percentage of samples,
the “normal” group has to comprise to be the normal group actually.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.calculatePolynomialResiduals">
<span class="sig-name descname"><span class="pre">calculatePolynomialResiduals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_periods</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.calculatePolynomialResiduals" title="Permalink to this definition">¶</a></dt>
<dd><p>Fits a polynomial model to the data and calculate the residuals.</p>
<p>The residual  is calculated by fitting a polynomial of degree <cite>order</cite> to a data
slice of size <cite>window</cite>, that has x at its center.</p>
<p>Note, that calculating the residuals tends to be quite costy, because a function
fitting is performed for every sample. To improve performance, consider the
following possibilities:</p>
<p>In case your data is sampled at an equidistant frequency grid:</p>
<p>(1) If you know your data to have no significant number of missing values,
or if you do not want to calculate residuals for windows containing missing values
any way, performance can be increased by setting min_periods=window.</p>
<p>Note, that the initial and final window/2 values do not get fitted.</p>
<p>Each residual gets assigned the worst flag present in the interval of
the original data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>field</strong> (<em>str</em>) – The column, holding the data-to-be-modelled.</p>
</dd>
</dl>
<dl class="simple">
<dt>window<span class="classifier">{str, int}</span></dt><dd><p>The size of the window you want to use for fitting. If an integer is passed,
the size refers to the number of periods for every fitting window. If an
offset string is passed, the size refers to the total temporal extension. The
window will be centered around the vaule-to-be-fitted. For regularly sampled
timeseries the period number will be casted down to an odd number if even.</p>
</dd>
<dt>order<span class="classifier">int</span></dt><dd><p>The degree of the polynomial used for fitting</p>
</dd>
<dt>min_periods<span class="classifier">int or None, default 0</span></dt><dd><p>The minimum number of periods, that has to be available in every values
fitting surrounding for the polynomial fit to be performed. If there are not
enough values, np.nan gets assigned. Default (0) results in fitting
regardless of the number of values present (results in overfitting for too
sparse intervals). To automatically set the minimum number of periods to the
number of values in an offset defined window size, pass np.nan.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.calculateRollingResiduals">
<span class="sig-name descname"><span class="pre">calculateRollingResiduals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func=&lt;function</span> <span class="pre">mean&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_periods=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.calculateRollingResiduals" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the diff of a rolling-window function and the data.</p>
<p>Note, that the data gets assigned the worst flag present in the original data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> (<em>str</em>) – The column to calculate on.</p></li>
<li><p><strong>window</strong> (<em>{int</em><em>, </em><em>str}</em>) – The size of the window you want to roll with. If an integer is passed, the size
refers to the number of periods for every fitting window. If an offset string
is passed, the size refers to the total temporal extension. For regularly
sampled timeseries, the period number will be casted down to an odd number if
<code class="docutils literal notranslate"><span class="pre">center=True</span></code>.</p></li>
<li><p><strong>func</strong> (<em>Callable</em><em>, </em><em>default np.mean</em>) – Function to roll with.</p></li>
<li><p><strong>min_periods</strong> (<em>int</em><em>, </em><em>default 0</em>) – The minimum number of periods to get a valid value</p></li>
<li><p><strong>center</strong> (<em>bool</em><em>, </em><em>default True</em>) – If True, center the rolling window.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.clearFlags">
<span class="sig-name descname"><span class="pre">clearFlags</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.clearFlags" title="Permalink to this definition">¶</a></dt>
<dd><p>Set whole column to UNFLAGGED.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> (<em>str</em>) – columns name that holds the data</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) – unused</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function ignores the <code class="docutils literal notranslate"><span class="pre">dfilter</span></code> keyword, because the data is not relevant
for processing.
A warning is triggered if the <code class="docutils literal notranslate"><span class="pre">flag</span></code> keyword is given, because the flags are
always set to <cite>UNFLAGGED</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.concatFlags">
<span class="sig-name descname"><span class="pre">concatFlags</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'match'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">drop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">squeeze</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.concatFlags" title="Permalink to this definition">¶</a></dt>
<dd><p>The Function appends flags history of <code class="docutils literal notranslate"><span class="pre">fields</span></code> to flags history of <code class="docutils literal notranslate"><span class="pre">target</span></code>.
Before appending, columns in <code class="docutils literal notranslate"><span class="pre">field</span></code> history are projected onto the target index via <code class="docutils literal notranslate"><span class="pre">method</span></code></p>
<p>method: (field_flag associated with “field”, source_flags associated with “source”)</p>
<ul class="simple">
<li><dl class="simple">
<dt>‘inverse_nagg’ - all target_flags within the range +/- freq/2 of a field_flag, get assigned this field flags value.</dt><dd><p>(if field_flag &gt; target_flag)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘inverse_bagg’ - all target_flags succeeding a field_flag within the range of “freq”, get assigned this field flags</dt><dd><p>value. (if field_flag &gt; target_flag)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘inverse_fagg’ - all target_flags preceeding a field_flag within the range of “freq”, get assigned this field flags</dt><dd><p>value. (if field_flag &gt; target_flag)</p>
</dd>
</dl>
</li>
<li><p>‘inverse_interpolation’ - all target_flags within the range +/- freq of a field_flag, get assigned this source flags value.
(if field_flag &gt; target_flag)</p></li>
<li><p>‘inverse_nshift’ - That target_flag within the range +/- freq/2, that is nearest to a field_flag, gets the source
flags value. (if field_flag &gt; target_flag)</p></li>
<li><dl class="simple">
<dt>‘inverse_bshift’ - That target_flag succeeding a field flag within the range freq, that is nearest to a</dt><dd><p>field_flag, gets assigned this field flags value. (if field_flag &gt; target_flag)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘inverse_nshift’ - That target_flag preceeding a field flag within the range freq, that is nearest to a</dt><dd><p>field_flag, gets assigned this field flags value. (if field_flag &gt; target_flag)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘match’ - any target_flag with a timestamp matching a field_flags timestamp gets this field_flags value</dt><dd><p>(if field_flag &gt; target_flag)</p>
</dd>
</dl>
</li>
</ul>
<p>Note, to undo or backtrack a resampling/shifting/interpolation that has been performed with a certain method,
you can just pass the associated “inverse” method. Also you should pass the same <code class="docutils literal notranslate"><span class="pre">drop</span></code> keyword.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>field</strong> (<em>str</em>) – Fieldname of flags history to append.</p>
</dd>
</dl>
<dl class="simple">
<dt>target<span class="classifier">str</span></dt><dd><p>Field name of flags history to append to.</p>
</dd>
<dt>method<span class="classifier">{‘inverse_fagg’, ‘inverse_bagg’, ‘inverse_nagg’, ‘inverse_fshift’, ‘inverse_bshift’, ‘inverse_nshift’, ‘match’}, default ‘match’</span></dt><dd><p>The method used for projection of <code class="docutils literal notranslate"><span class="pre">field</span></code> flags onto <code class="docutils literal notranslate"><span class="pre">target</span></code> flags. See description above for more details.</p>
</dd>
<dt>freq<span class="classifier">str or None, default None</span></dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">freq</span></code> determines the projection range for the projection method. See above description for more details.
Defaultly (None), the sampling frequency of <code class="docutils literal notranslate"><span class="pre">field</span></code> is used.</p>
</dd>
<dt>drop<span class="classifier">bool, default False</span></dt><dd><p>If set to <cite>True</cite>, the <cite>field</cite> column will be removed after processing</p>
</dd>
<dt>squeeze<span class="classifier">bool, default False</span></dt><dd><p>If set to <cite>True</cite>, the appended flags frame will be squeezed - resulting in function specific flags informations
getting lost.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/saqc/core/core.html#SaQC.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#saqc.SaQC.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.copyField">
<span class="sig-name descname"><span class="pre">copyField</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.copyField" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy data and flags to a new name (preserve flags history).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> (<em>str</em>) – The fieldname of the data column, you want to fork (copy).</p></li>
<li><p><strong>target</strong> (<em>str</em>) – Target name.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.correctDrift">
<span class="sig-name descname"><span class="pre">correctDrift</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maintenance_field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cal_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.correctDrift" title="Permalink to this definition">¶</a></dt>
<dd><p>The function corrects drifting behavior.</p>
<p>See the Notes section for an overview over the correction algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>field</strong> (<em>str</em>) – Column in data and flags.</p>
</dd>
</dl>
<dl class="simple">
<dt>maintenance_field<span class="classifier">str</span></dt><dd><p>Column holding the support-points information.
The data is expected to have the following form:
The index of the series represents the beginning of a maintenance
event, wheras the values represent its endings.</p>
</dd>
<dt>model<span class="classifier">Callable or {‘exponential’, ‘linear’}</span></dt><dd><p>A modelfunction describing the drift behavior, that is to be corrected.
Either use built-in exponential or linear drift model by passing a string, or pass a custom callable.
The model function must always contain the keyword parameters ‘origin’ and ‘target’.
The starting parameter must always be the parameter, by wich the data is passed to the model.
After the data parameter, there can occure an arbitrary number of model calibration arguments in
the signature.
See the Notes section for an extensive description.</p>
</dd>
<dt>cal_range<span class="classifier">int, default 5</span></dt><dd><p>Number of values to calculate the mean of, for obtaining the value level directly
after and directly before a maintenance event. Needed for shift calibration.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>It is assumed, that between support points, there is a drift effect shifting the
meassurements in a way, that can be described, by a model function M(t, p, origin, target).
(With 0&lt;=t&lt;=1, p being a parameter set, and origin, target being floats).</p>
<p>Note, that its possible for the model to have no free parameters p at all. (linear drift mainly)</p>
<p>The drift model, directly after the last support point (t=0),
should evaluate to the origin - calibration level (origin), and directly before the next
support point (t=1), it should evaluate to the target calibration level (target).</p>
<blockquote>
<div><p>M(0, p, origin, target) = origin
M(1, p, origin, target) = target</p>
</div></blockquote>
<p>The model is than fitted to any data chunk in between support points, by optimizing
the parameters p, and thus, obtaining optimal parameterset P.</p>
<p>The new values at t are computed via::</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">new_vals</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">old_vals</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">M</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="o">-</span> <span class="n">M_drift</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">new_target</span><span class="p">)</span>
</pre></div>
</div>
<p>Wheras <code class="docutils literal notranslate"><span class="pre">new_target</span></code> represents the value level immediately after the next support point.</p>
<p class="rubric">Examples</p>
<p>Some examples of meaningful driftmodels.</p>
<p>Linear drift modell (no free parameters).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Model</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">origin</span> <span class="o">+</span> <span class="n">t</span><span class="o">*</span><span class="n">target</span>
</pre></div>
</div>
<p>exponential drift model (exponential raise!)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expFunc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Model</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">expFunc</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">origin</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
</pre></div>
</div>
<p>Exponential and linear driftmodels are part of the <code class="docutils literal notranslate"><span class="pre">ts_operators</span></code> library, under the names
<code class="docutils literal notranslate"><span class="pre">expDriftModel</span></code> and <code class="docutils literal notranslate"><span class="pre">linearDriftModel</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.correctOffset">
<span class="sig-name descname"><span class="pre">correctOffset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_jump</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spread</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_periods</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.correctOffset" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> (<em>str</em>) – The fieldname of the data column, you want to correct.</p></li>
<li><p><strong>max_jump</strong> (<em>float</em>) – when searching for changepoints in mean - this is the threshold a mean difference in the
sliding window search must exceed to trigger changepoint detection.</p></li>
<li><p><strong>spread</strong> (<em>float</em>) – threshold denoting the maximum, regimes are allowed to abolutely differ in their means
to form the “normal group” of values.</p></li>
<li><p><strong>window</strong> (<em>str</em>) – Size of the adjacent windows that are used to search for the mean changepoints.</p></li>
<li><p><strong>min_periods</strong> (<em>int</em>) – Minimum number of periods a search window has to contain, for the result of the changepoint
detection to be considered valid.</p></li>
<li><p><strong>tolerance</strong> (<em>{None</em><em>, </em><em>str}</em><em>, </em><em>default None:</em>) – If an offset string is passed, a data chunk of length <cite>offset</cite> right from the
start and right before the end of any regime is ignored when calculating a regimes mean for data correcture.
This is to account for the unrelyability of data near the changepoints of regimes.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.correctRegimeAnomaly">
<span class="sig-name descname"><span class="pre">correctRegimeAnomaly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cluster_field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epoch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.correctRegimeAnomaly" title="Permalink to this definition">¶</a></dt>
<dd><p>Function fits the passed model to the different regimes in data[field] and tries to correct
those values, that have assigned a negative label by data[cluster_field].</p>
<p>Currently, the only correction mode supported is the “parameter propagation.”</p>
<p>This means, any regime <span class="math notranslate nohighlight">\(z\)</span>, labeled negatively and being modeled by the parameters p, gets corrected via:</p>
<p><span class="math notranslate nohighlight">\(z_{correct} = z + (m(p^*) - m(p))\)</span>,</p>
<p>where <span class="math notranslate nohighlight">\(p^*\)</span> denotes the parameter set belonging to the fit of the nearest not-negatively labeled cluster.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> (<em>str</em>) – The fieldname of the data column, you want to correct.</p></li>
<li><p><strong>cluster_field</strong> (<em>str</em>) – A string denoting the field in data, holding the cluster label for the data you want to correct.</p></li>
<li><p><strong>model</strong> (<em>Callable</em>) – The model function to be fitted to the regimes.
It must be a function of the form <span class="math notranslate nohighlight">\(f(x, *p)\)</span>, where <span class="math notranslate nohighlight">\(x\)</span> is the <code class="docutils literal notranslate"><span class="pre">numpy.array</span></code> holding the
independent variables and <span class="math notranslate nohighlight">\(p\)</span> are the model parameters that are to be obtained by fitting.
Depending on the <cite>x_date</cite> parameter, independent variable x will either be the timestamps
of every regime transformed to seconds from epoch, or it will be just seconds, counting the regimes length.</p></li>
<li><p><strong>tolerance</strong> (<em>{None</em><em>, </em><em>str}</em><em>, </em><em>default None:</em>) – If an offset string is passed, a data chunk of length <cite>offset</cite> right at the
start and right at the end is ignored when fitting the model. This is to account for the
unreliability of data near the changepoints of regimes.</p></li>
<li><p><strong>epoch</strong> (<em>bool</em><em>, </em><em>default False</em>) – If True, use “seconds from epoch” as x input to the model func, instead of “seconds from regime start”.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.dropField">
<span class="sig-name descname"><span class="pre">dropField</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.dropField" title="Permalink to this definition">¶</a></dt>
<dd><p>Drops field from the data and flags.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>field</strong> (<em>str</em>) – The fieldname of the data column, you want to drop.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.fitPolynomial">
<span class="sig-name descname"><span class="pre">fitPolynomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_periods</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.fitPolynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Fits a polynomial model to the data.</p>
<p>The fit is calculated by fitting a polynomial of degree <cite>order</cite> to a data slice
of size <cite>window</cite>, that has x at its center.</p>
<p>Note that the result is stored in <cite>field</cite> and overwrite it unless a
<cite>target</cite> is given.</p>
<p>In case your data is sampled at an equidistant frequency grid:</p>
<p>(1) If you know your data to have no significant number of missing values,
or if you do not want to calculate residuals for windows containing missing values
any way, performance can be increased by setting min_periods=window.</p>
<p>Note, that the initial and final window/2 values do not get fitted.</p>
<p>Each residual gets assigned the worst flag present in the interval of
the original data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>field</strong> (<em>str</em>) – A column in flags and data.</p>
</dd>
</dl>
<dl class="simple">
<dt>window<span class="classifier">str, int</span></dt><dd><p>Size of the window you want to use for fitting. If an integer is passed,
the size refers to the number of periods for every fitting window. If an
offset string is passed, the size refers to the total temporal extension. The
window will be centered around the vaule-to-be-fitted. For regularly sampled
data always a odd number of periods will be used for the fit (periods-1 if
periods is even).</p>
</dd>
<dt>order<span class="classifier">int</span></dt><dd><p>Degree of the polynomial used for fitting</p>
</dd>
<dt>min_periods<span class="classifier">int or None, default 0</span></dt><dd><p>Minimum number of observations in a window required to perform the fit,
otherwise NaNs will be assigned.
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, <cite>min_periods</cite> defaults to 1 for integer windows and to the
size of the window for offset based windows.
Passing 0, disables the feature and will result in over-fitting for too
sparse windows.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.flagByGrubbs">
<span class="sig-name descname"><span class="pre">flagByGrubbs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_periods</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pedantic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">255.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.flagByGrubbs" title="Permalink to this definition">¶</a></dt>
<dd><p>The function flags values that are regarded outliers due to the grubbs test.</p>
<p>See reference [1] for more information on the grubbs tests definition.</p>
<p>The (two-sided) test gets applied onto data chunks of size “window”. The tests
application  will be iterated on each data-chunk under test, till no more
outliers are detected in that chunk.</p>
<p>Note, that the test performs poorely for small data chunks (resulting in heavy
overflagging). Therefor you should select “window” so that every window contains
at least &gt; 8 values and also adjust the min_periods values accordingly.</p>
<p>Note, that the data to be tested by the grubbs test are expected to be distributed
“normalish”.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> (<em>str</em>) – The fieldname of the column, holding the data-to-be-flagged.</p></li>
<li><p><strong>window</strong> (<em>{int</em><em>, </em><em>str}</em>) – The size of the window you want to use for outlier testing. If an integer is
passed, the size refers to the number of periods of every testing window. If a
string is passed, it has to be an offset string, and will denote the total
temporal extension of every window.</p></li>
<li><p><strong>alpha</strong> (<em>float</em><em>, </em><em>default 0.05</em>) – The level of significance, the grubbs test is to be performed at. (between 0 and 1)</p></li>
<li><p><strong>min_periods</strong> (<em>int</em><em>, </em><em>default 8</em>) – The minimum number of values that have to be present in an interval under test,
for a grubbs test result to be accepted. Only makes sence in case <cite>window</cite> is
an offset string.</p></li>
<li><p><strong>pedantic</strong> (<em>boolean</em><em>, </em><em>default False</em>) – If True, every value gets checked twice for being an outlier. Ones in the
initial rolling window and one more time in a rolling window that is lagged
by half the windows delimeter (window/2). Recommended for avoiding false
positives at the window edges. Only available when rolling with integer
defined window size.</p></li>
<li><p><strong>flag</strong> (<em>float</em><em>, </em><em>default BAD</em>) – flag to set.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
<p class="rubric">References</p>
<p>introduction to the grubbs test:</p>
<p>[1] <a class="reference external" href="https://en.wikipedia.org/wiki/Grubbs%27s_test_for_outliers">https://en.wikipedia.org/wiki/Grubbs%27s_test_for_outliers</a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.flagByStatLowPass">
<span class="sig-name descname"><span class="pre">flagByStatLowPass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thresh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sub_window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sub_thresh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_periods</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">255.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.flagByStatLowPass" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag <em>chunks</em> of length, <cite>window</cite>:</p>
<ol class="arabic simple">
<li><p>If they excexceed <cite>thresh</cite> with regard to <cite>stat</cite>:</p></li>
<li><p>If all (maybe overlapping) <em>sub-chunks</em> of <em>chunk</em>, with length <cite>sub_window</cite>,
<cite>excexceed `sub_thresh</cite> with regard to <cite>stat</cite>:</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> (<em>str</em>) – The fieldname of the column, holding the data-to-be-flagged.</p></li>
<li><p><strong>func</strong> (<em>Callable</em><em>[</em><em>[</em><em>np.array</em><em>, </em><em>pd.Series</em><em>]</em><em>, </em><em>float</em><em>]</em>) – Function to aggregate chunk contnent with.</p></li>
<li><p><strong>window</strong> (<em>str</em>) – Temporal extension of the chunks to test</p></li>
<li><p><strong>thresh</strong> (<em>float</em>) – Threshold, that triggers flagging, if exceeded by stat value.</p></li>
<li><p><strong>sub_window</strong> (<em>str</em><em>, </em><em>default None</em><em>,</em>) – Window size of the sub chunks, that are additionally tested for exceeding
<cite>sub_thresh</cite> with respect to <cite>stat</cite>.</p></li>
<li><p><strong>sub_thresh</strong> (<em>float</em><em>, </em><em>default None</em>) – </p></li>
<li><p><strong>min_periods</strong> (<em>int</em><em>, </em><em>default None</em>) – </p></li>
<li><p><strong>flag</strong> (<em>float</em><em>, </em><em>default BAD</em>) – flag to set</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.flagByStray">
<span class="sig-name descname"><span class="pre">flagByStray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_periods</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">11</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iter_start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">255.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.flagByStray" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag outliers in 1-dimensional (score) data with the STRAY Algorithm.</p>
<p>Find more information on the algorithm in References [1].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> (<em>str</em>) – The fieldname of the column, holding the data-to-be-flagged.</p></li>
<li><p><strong>freq</strong> (<em>str</em><em>, </em><em>int</em><em>, or </em><em>None</em><em>, </em><em>default None</em>) – <p>Determines the segmentation of the data into partitions, the kNN algorithm is
applied onto individually.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">np.inf</span></code>: Apply Scoring on whole data set at once</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> &gt; 0 : Apply scoring on successive data chunks of periods length <code class="docutils literal notranslate"><span class="pre">x</span></code></p></li>
<li><p>Offset String : Apply scoring on successive partitions of temporal extension
matching the passed offset string</p></li>
</ul>
</p></li>
<li><p><strong>min_periods</strong> (<em>int</em><em>, </em><em>default 11</em>) – Minimum number of periods per partition that have to be present for a valid
outlier dettection to be made in this partition. (Only of effect, if <cite>freq</cite>
is an integer.) Partition min value must always be greater then the
nn_neighbors value.</p></li>
<li><p><strong>iter_start</strong> (<em>float</em><em>, </em><em>default 0.5</em>) – Float in [0,1] that determines which percentage of data is considered
“normal”. 0.5 results in the stray algorithm to search only the upper 50 % of
the scores for the cut off point. (See reference section for more information)</p></li>
<li><p><strong>alpha</strong> (<em>float</em><em>, </em><em>default 0.05</em>) – Level of significance by which it is tested, if a score might be drawn from
another distribution, than the majority of the data.</p></li>
<li><p><strong>flag</strong> (<em>float</em><em>, </em><em>default BAD</em>) – flag to set.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="simple">
<dt>[1] Talagala, P. D., Hyndman, R. J., &amp; Smith-Miles, K. (2019). Anomaly detection in</dt><dd><p>high dimensional data. arXiv preprint arXiv:1908.04000.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.flagByVariance">
<span class="sig-name descname"><span class="pre">flagByVariance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thresh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxna</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxna_group</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">255.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.flagByVariance" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag low-variance data.</p>
<p>Flags plateaus of constant data if the variance in a rolling window does not
exceed a certain threshold.</p>
<p>Any interval of values y(t),..y(t+n) is flagged, if:</p>
<ol class="arabic simple">
<li><p>n &gt; <cite>window</cite></p></li>
<li><p>variance(y(t),…,y(t+n) &lt; <cite>thresh</cite></p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>field</strong> (<em>str</em>) – A column in flags and data.</p>
</dd>
</dl>
<dl class="simple">
<dt>window<span class="classifier">str | int</span></dt><dd><p>Size of the moving window. This is the number of observations used
for calculating the statistic. Each window will be a fixed size.
If its an offset then this will be the time period of each window.
Each window will be sized, based on the number of observations included
in the time-period.</p>
</dd>
<dt>thresh<span class="classifier">float, default 0.0005</span></dt><dd><p>Maximum total variance allowed per window.</p>
</dd>
<dt>maxna<span class="classifier">int, default None</span></dt><dd><p>Maximum number of NaNs allowed in window.
If more NaNs are present, the window is not flagged.</p>
</dd>
<dt>maxna_group<span class="classifier">int, default None</span></dt><dd><p>Same as <cite>maxna</cite> but for consecutive NaNs.</p>
</dd>
<dt>flag<span class="classifier">float, default BAD</span></dt><dd><p>Flag to set.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.flagChangePoints">
<span class="sig-name descname"><span class="pre">flagChangePoints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stat_func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thresh_func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_periods</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">closed='both'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduce_window=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduce_func=&lt;function</span> <span class="pre">ChangePoints.&lt;lambda&gt;&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag=255.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.flagChangePoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag data where it significantly changes.</p>
<p>Flag data points, where the parametrization of the process, the data is assumed to
generate by, significantly changes.</p>
<p>The change points detection is based on a sliding window search.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>field</strong> (<em>str</em>) – A column in flags and data.</p>
</dd>
</dl>
<dl>
<dt>stat_func<span class="classifier">Callable</span></dt><dd><p>A function that assigns a value to every twin window. The backward-facing
window content will be passed as the first array, the forward-facing window
content as the second.</p>
</dd>
<dt>thresh_func<span class="classifier">Callable</span></dt><dd><p>A function that determines the value level, exceeding wich qualifies a
timestamps func value as denoting a change-point.</p>
</dd>
<dt>window<span class="classifier">str, tuple of str</span></dt><dd><p>Size of the moving windows. This is the number of observations used for
calculating the statistic.</p>
<p>If it is a single frequency offset, it applies for the backward- and the
forward-facing window.</p>
<p>If two offsets (as a tuple) is passed the first defines the size of the
backward facing window, the second the size of the forward facing window.</p>
</dd>
<dt>min_periods<span class="classifier">int or tuple of int</span></dt><dd><p>Minimum number of observations in a window required to perform the changepoint
test. If it is a tuple of two int, the first refer to the backward-,
the second to the forward-facing window.</p>
</dd>
<dt>closed<span class="classifier">{‘right’, ‘left’, ‘both’, ‘neither’}, default ‘both’</span></dt><dd><p>Determines the closure of the sliding windows.</p>
</dd>
<dt>reduce_window<span class="classifier">str or None, default None</span></dt><dd><p>The sliding window search method is not an exact CP search method and usually
there wont be detected a single changepoint, but a “region” of change around
a changepoint.</p>
<p>If <cite>reduce_window</cite> is given, for every window of size <cite>reduce_window</cite>, there
will be selected the value with index <cite>reduce_func(x, y)</cite> and the others will
be dropped.</p>
<p>If <cite>reduce_window</cite> is None, the reduction window size equals the twin window
size, the changepoints have been detected with.</p>
</dd>
<dt>reduce_func<span class="classifier">Callable, default <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">x,</span> <span class="pre">y:</span> <span class="pre">x.argmax()</span></code></span></dt><dd><p>A function that must return an index value upon input of two arrays x and y.
First input parameter will hold the result from the stat_func evaluation for
every reduction window. Second input parameter holds the result from the
<cite>thresh_func</cite> evaluation.
The default reduction function just selects the value that maximizes the
<cite>stat_func</cite>.</p>
</dd>
<dt>flag<span class="classifier">float, default BAD</span></dt><dd><p>flag to set.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.flagConstants">
<span class="sig-name descname"><span class="pre">flagConstants</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thresh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">255.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.flagConstants" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag constant data values.</p>
<p>Flags plateaus of constant data if their maximum total change in
a rolling window does not exceed a certain threshold.</p>
<dl class="simple">
<dt>Any interval of values y(t),…,y(t+n) is flagged, if:</dt><dd><ul class="simple">
<li><p>(1): n &gt; <code class="docutils literal notranslate"><span class="pre">window</span></code></p></li>
<li><p>(2): abs(y(t + i) - (t + j)) &lt; <cite>thresh</cite>, for all i,j in [0, 1, …, n]</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>field</strong> (<em>str</em>) – A column in flags and data.</p>
</dd>
</dl>
<dl class="simple">
<dt>thresh<span class="classifier">float</span></dt><dd><p>Maximum total change allowed per window.</p>
</dd>
<dt>window<span class="classifier">str | int</span></dt><dd><p>Size of the moving window. This is the number of observations used
for calculating the statistic. Each window will be a fixed size.
If its an offset then this will be the time period of each window.
Each window will be a variable sized based on the observations included
in the time-period.</p>
</dd>
<dt>flag<span class="classifier">float, default BAD</span></dt><dd><p>Flag to set.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.flagCrossStatistics">
<span class="sig-name descname"><span class="pre">flagCrossStatistics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thresh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'modZscore'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">255.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.flagCrossStatistics" title="Permalink to this definition">¶</a></dt>
<dd><p>Function checks for outliers relatively to the “horizontal” input data axis.</p>
<p>For <cite>fields</cite> <span class="math notranslate nohighlight">\(=[f_1,f_2,...,f_N]\)</span> and timestamps <span class="math notranslate nohighlight">\([t_1,t_2,...,t_K]\)</span>, the following steps are taken
for outlier detection:</p>
<ol class="arabic simple">
<li><p>All timestamps <span class="math notranslate nohighlight">\(t_i\)</span>, where there is one <span class="math notranslate nohighlight">\(f_k\)</span>, with <span class="math notranslate nohighlight">\(data[f_K]\)</span> having no entry at
<span class="math notranslate nohighlight">\(t_i\)</span>, are excluded from the following process (inner join of the <span class="math notranslate nohighlight">\(f_i\)</span> fields.)</p></li>
<li><p>for every <span class="math notranslate nohighlight">\(0 &lt;= i &lt;= K\)</span>, the value
<span class="math notranslate nohighlight">\(m_j = median(\{data[f_1][t_i], data[f_2][t_i], ..., data[f_N][t_i]\})\)</span> is calculated</p></li>
<li><p>for every <span class="math notranslate nohighlight">\(0 &lt;= i &lt;= K\)</span>, the set
<span class="math notranslate nohighlight">\(\{data[f_1][t_i] - m_j, data[f_2][t_i] - m_j, ..., data[f_N][t_i] - m_j\}\)</span> is tested for outliers with the
specified method (<cite>cross_stat</cite> parameter).</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> (<em>list of str</em>) – List of fieldnames in data, determining wich variables are to be included into the flagging process.</p></li>
<li><p><strong>thresh</strong> (<em>float</em>) – Threshold which the outlier score of an value must exceed, for being flagged an outlier.</p></li>
<li><p><strong>method</strong> (<em>{'modZscore'</em><em>, </em><em>'Zscore'}</em><em>, </em><em>default 'modZscore'</em>) – <p>Method used for calculating the outlier scores.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'modZscore'</span></code>: Median based “sigma”-ish approach. See Referenecs [1].</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Zscore'</span></code>: Score values by how many times the standard deviation they differ from the median.
See References [1]</p></li>
</ul>
</p></li>
<li><p><strong>flag</strong> (<em>float</em><em>, </em><em>default BAD</em>) – flag to set.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The input variables dont necessarily have to be aligned. If the variables are unaligned, scoring
and flagging will be only performed on the subset of inices shared among all input variables.</p>
<p class="rubric">References</p>
<p>[1] <a class="reference external" href="https://www.itl.nist.gov/div898/handbook/eda/section3/eda35h.htm">https://www.itl.nist.gov/div898/handbook/eda/section3/eda35h.htm</a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.flagDriftFromNorm">
<span class="sig-name descname"><span class="pre">flagDriftFromNorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spread</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frac=0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric=&lt;function</span> <span class="pre">Drift.&lt;lambda&gt;&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method='single'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag=255.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.flagDriftFromNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Flags data that deviates from an avarage data course.</p>
<p>“Normality” is determined in terms of a maximum spreading distance,
that members of a normal group must not exceed. In addition, only a group is considered
“normal” if it contains more then <cite>frac</cite> percent of the variables in “field”.</p>
<p>See the Notes section for a more detailed presentation of the algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>field</strong> (<em>str</em>) – A column in flags and data.</p>
</dd>
</dl>
<dl>
<dt>freq<span class="classifier">str</span></dt><dd><p>Frequency, that split the data in chunks.</p>
</dd>
<dt>spread<span class="classifier">float</span></dt><dd><p>Maximum spread allowed in the group of <em>normal</em> data. See Notes section for more details.</p>
</dd>
<dt>frac<span class="classifier">float, default 0.5</span></dt><dd><p>Fraction defining the normal group. Use a value from the interval [0,1].
The higher the value, the more stable the algorithm will be. For values below
0.5 the results are undefined.</p>
</dd>
<dt>metric<span class="classifier">Callable, default <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">x,y:pdist(np.array([x,y]),metric=&quot;cityblock&quot;)/len(x)</span></code></span></dt><dd><p>Distance function that takes two arrays as input and returns a scalar float.
This value is interpreted as the distance of the two input arrays.
Defaults to the <cite>averaged manhattan metric</cite> (see Notes).</p>
</dd>
<dt>method<span class="classifier">{“single”, “complete”, “average”, “weighted”, “centroid”, “median”, “ward”}, default “single”</span></dt><dd><p>Linkage method used for hierarchical (agglomerative) clustering of the data.
<cite>method</cite> is directly passed to <code class="docutils literal notranslate"><span class="pre">scipy.hierarchy.linkage</span></code>. See its documentation [1] for
more details. For a general introduction on hierarchical clustering see [2].</p>
</dd>
<dt>flag<span class="classifier">float, default BAD</span></dt><dd><p>flag to set.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>following steps are performed for every data “segment” of length <cite>freq</cite> in order to find the
“abnormal” data:</p>
<ol class="arabic">
<li><p>Calculate distances <span class="math notranslate nohighlight">\(d(x_i,x_j)\)</span> for all <span class="math notranslate nohighlight">\(x_i\)</span> in parameter <cite>field</cite>.
(with <span class="math notranslate nohighlight">\(d\)</span> denoting the distance function, specified by <cite>metric</cite>.</p></li>
<li><p>Calculate a dendogram with a hierarchical linkage algorithm, specified by <cite>method</cite>.</p></li>
<li><p>Flatten the dendogram at the level, the agglomeration costs exceed <cite>spread</cite></p></li>
<li><p>check if a cluster containing more than <cite>frac</cite> variables.</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>if yes: flag all the variables that are not in that cluster (inside the segment)</p></li>
<li><p>if no: flag nothing</p></li>
</ol>
</div></blockquote>
</li>
</ol>
<p>The main parameter giving control over the algorithms behavior is the <cite>spread</cite> parameter,
that determines the maximum spread of a normal group by limiting the costs, a cluster
agglomeration must not exceed in every linkage step.
For singleton clusters, that costs just equal half the distance, the data in the
clusters, have to each other. So, no data can be clustered together, that are more then
2*`spread` distances away from each other. When data get clustered together, this new
clusters distance to all the other data/clusters is calculated according to the linkage
method specified by <cite>method</cite>. By default, it is the minimum distance, the members of the
clusters have to each other. Having that in mind, it is advisable to choose a distance
function, that can be well interpreted in the units dimension of the measurement and where
the interpretation is invariant over the length of the data. That is, why,
the “averaged manhattan metric” is set as the metric default, since it corresponds to the
averaged value distance, two data sets have (as opposed by euclidean, for example).</p>
<p class="rubric">References</p>
<dl class="simple">
<dt>Documentation of the underlying hierarchical clustering algorithm:</dt><dd><p>[1] <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.linkage.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.linkage.html</a></p>
</dd>
<dt>Introduction to Hierarchical clustering:</dt><dd><p>[2] <a class="reference external" href="https://en.wikipedia.org/wiki/Hierarchical_clustering">https://en.wikipedia.org/wiki/Hierarchical_clustering</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.flagDriftFromReference">
<span class="sig-name descname"><span class="pre">flagDriftFromReference</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thresh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric=&lt;function</span> <span class="pre">Drift.&lt;lambda&gt;&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag=255.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.flagDriftFromReference" title="Permalink to this definition">¶</a></dt>
<dd><p>Flags data that deviates from a reference course.</p>
<p>The deviation is measured by a passed distance function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>field</strong> (<em>str</em>) – A column in flags and data.</p>
</dd>
</dl>
<dl class="simple">
<dt>freq<span class="classifier">str</span></dt><dd><p>Frequency, that split the data in chunks.</p>
</dd>
<dt>reference<span class="classifier">str</span></dt><dd><p>Reference variable, the deviation is calculated from.</p>
</dd>
<dt>thresh<span class="classifier">float</span></dt><dd><p>Maximum deviation from reference.</p>
</dd>
<dt>metric<span class="classifier">Callable</span></dt><dd><p>Distance function. Takes two arrays as input and returns a scalar float.
This value is interpreted as the mutual distance of the two input arrays.
Defaults to the <cite>averaged manhattan metric</cite> (see Notes).</p>
</dd>
<dt>target<span class="classifier">None</span></dt><dd><p>Ignored.</p>
</dd>
<dt>flag<span class="classifier">float, default BAD</span></dt><dd><p>Flag to set.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>It is advisable to choose a distance function, that can be well interpreted in
the units dimension of the measurement and where the interpretation is invariant over the
length of the data. That is, why, the “averaged manhatten metric” is set as the metric
default, since it corresponds to the averaged value distance, two data sets have (as opposed
by euclidean, for example).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.flagDummy">
<span class="sig-name descname"><span class="pre">flagDummy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.flagDummy" title="Permalink to this definition">¶</a></dt>
<dd><p>Set whole column to a flag value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> (<em>str</em>) – columns name that holds the data</p></li>
<li><p><strong>flag</strong> (<em>float</em><em>, </em><em>default BAD</em>) – flag to set</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) – unused</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.flagGeneric">
<span class="sig-name descname"><span class="pre">flagGeneric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">255.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dfilter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">inf</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.flagGeneric" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag data with user defined functions.</p>
<p>Formally, what the function does, is the following:
Let X be a Callable, depending on fields f_1, f_2,…f_K, (X = X(f_1, f_2,…f_K))
Than for every timestamp t_i in data[field]:
data[field][t_i] is flagged if X(data[f_1][t_i], data[f_2][t_i], …, data[f_K][t_i]) is True.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> (<em>str</em><em> or </em><em>list of str</em>) – The variable(s) passed to func.</p></li>
<li><p><strong>func</strong> (<em>callable</em>) – Function to call on the variables given in <code class="docutils literal notranslate"><span class="pre">field</span></code>. The function needs to accept the same
number of arguments (of type pandas.Series) as variables given in <code class="docutils literal notranslate"><span class="pre">field</span></code> and return an
iterable of array-like objects of with dtype bool and with the same number of elements as
given in <code class="docutils literal notranslate"><span class="pre">target</span></code> (or <code class="docutils literal notranslate"><span class="pre">field</span></code> if <code class="docutils literal notranslate"><span class="pre">target</span></code> is not specified). The function output
determines the values to flag.</p></li>
<li><p><strong>target</strong> (<em>str</em><em> or </em><em>list of str</em>) – The variable(s) to write the result of <code class="docutils literal notranslate"><span class="pre">func</span></code> to. If not given, the variable(s)
specified in <code class="docutils literal notranslate"><span class="pre">field</span></code> will be overwritten. If a <code class="docutils literal notranslate"><span class="pre">target</span></code> is not given, it will be
created.</p></li>
<li><p><strong>flag</strong> (float, default <code class="docutils literal notranslate"><span class="pre">BAD</span></code>) – The quality flag to set. The default <code class="docutils literal notranslate"><span class="pre">BAD</span></code> states the general idea, that
<code class="docutils literal notranslate"><span class="pre">processGeneric</span></code> generates ‘new’ data without direct relation to the potentially
already present flags.</p></li>
<li><p><strong>dfilter</strong> (float, default <code class="docutils literal notranslate"><span class="pre">FILTER_ALL</span></code>) – Threshold flag. Flag values greater than <code class="docutils literal notranslate"><span class="pre">dfilter</span></code> indicate that the associated
data value is inappropiate for further usage.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<ol class="arabic simple">
<li><p>Flag the variable ‘rainfall’, if the sum of the variables ‘temperature’ and ‘uncertainty’ is below zero:</p></li>
</ol>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span><span class="o">.</span><span class="n">flagGeneric</span><span class="p">(</span><span class="n">field</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;temperature&quot;</span><span class="p">,</span> <span class="s2">&quot;uncertainty&quot;</span><span class="p">],</span> <span class="n">target</span><span class="o">=</span><span class="s2">&quot;rainfall&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>Flag the variable ‘temperature’, where the variable ‘fan’ is flagged:</p></li>
</ol>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span><span class="o">.</span><span class="n">flagGeneric</span><span class="p">(</span><span class="n">field</span><span class="o">=</span><span class="s2">&quot;fan&quot;</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="s2">&quot;temperature&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">isflagged</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li><p>The generic functions also support all pandas and numpy functions:</p></li>
</ol>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">flagGeneric</span><span class="p">(</span><span class="n">field</span><span class="o">=</span><span class="s2">&quot;fan&quot;</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="s2">&quot;temperature&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">7</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.flagIsolated">
<span class="sig-name descname"><span class="pre">flagIsolated</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gap_window</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group_window</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">255.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.flagIsolated" title="Permalink to this definition">¶</a></dt>
<dd><p>Find and flag temporal isolated groups of data.</p>
<p>The function flags arbitrarily large groups of values, if they are surrounded by
sufficiently large data gaps. A gap is a timespan containing either no data at all
or NaNs only.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>field</strong> (<em>str</em>) – Column(s) in flags and data.</p>
</dd>
</dl>
<dl class="simple">
<dt>gap_window<span class="classifier">str</span></dt><dd><p>Minimum gap size required before and after a data group to consider it
isolated. See condition (2) and (3)</p>
</dd>
<dt>group_window<span class="classifier">str</span></dt><dd><p>Maximum size of a data chunk to consider it a candidate for an isolated group.
Data chunks that are bigger than the <code class="docutils literal notranslate"><span class="pre">group_window</span></code> are ignored.
This does not include the possible gaps surrounding it.
See condition (1).</p>
</dd>
<dt>flag<span class="classifier">float, default BAD</span></dt><dd><p>Flag to set.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>A series of values <span class="math notranslate nohighlight">\(x_k,x_{k+1},...,x_{k+n}\)</span>, with associated
timestamps <span class="math notranslate nohighlight">\(t_k,t_{k+1},...,t_{k+n}\)</span>, is considered to be isolated, if:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(t_{k+1} - t_n &lt;\)</span> <cite>group_window</cite></p></li>
<li><dl class="simple">
<dt>None of the <span class="math notranslate nohighlight">\(x_j\)</span> with <span class="math notranslate nohighlight">\(0 &lt; t_k - t_j &lt;\)</span> <cite>gap_window</cite>,</dt><dd><p>is valid (preceeding gap).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>None of the <span class="math notranslate nohighlight">\(x_j\)</span> with <span class="math notranslate nohighlight">\(0 &lt; t_j - t_(k+n) &lt;\)</span> <cite>gap_window</cite>,</dt><dd><p>is valid (succeding gap).</p>
</dd>
</dl>
</li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.flagJumps">
<span class="sig-name descname"><span class="pre">flagJumps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thresh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_periods</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">255.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.flagJumps" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag jumps and drops in data.</p>
<p>Flag data where the mean of its values significantly changes (the data “jumps”).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>field</strong> (<em>str</em>) – Column(s) in flags and data.</p>
</dd>
</dl>
<dl class="simple">
<dt>thresh<span class="classifier">float</span></dt><dd><p>Threshold value by which the mean of data has to change to trigger flagging.</p>
</dd>
<dt>window<span class="classifier">str</span></dt><dd><p>Size of the moving window. This is the number of observations used
for calculating the statistic.</p>
</dd>
<dt>min_periods<span class="classifier">int, default 1</span></dt><dd><p>Minimum number of observations in window required to calculate a valid
mean value.</p>
</dd>
<dt>flag<span class="classifier">float, default BAD</span></dt><dd><p>Flag to set.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.flagMAD">
<span class="sig-name descname"><span class="pre">flagMAD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">255.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.flagMAD" title="Permalink to this definition">¶</a></dt>
<dd><p>The function represents an implementation of the modyfied Z-score outlier detection method.</p>
<p>See references [1] for more details on the algorithm.</p>
<p>Note, that the test needs the input data to be sampled regularly (fixed sampling rate).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> (<em>str</em>) – The fieldname of the column, holding the data-to-be-flagged. (Here a dummy, for structural reasons)</p></li>
<li><p><strong>window</strong> (<em>str</em>) – Offset string. Denoting the windows size that the “Z-scored” values have to lie in.</p></li>
<li><p><strong>z</strong> (<em>float</em><em>, </em><em>default 3.5</em>) – The value the Z-score is tested against. Defaulting to 3.5 (Recommendation of [1])</p></li>
<li><p><strong>flag</strong> (<em>float</em><em>, </em><em>default BAD</em>) – flag to set.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
<p class="rubric">References</p>
<p>[1] <a class="reference external" href="https://www.itl.nist.gov/div898/handbook/eda/section3/eda35h.htm">https://www.itl.nist.gov/div898/handbook/eda/section3/eda35h.htm</a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.flagMVScores">
<span class="sig-name descname"><span class="pre">flagMVScores</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trafo=&lt;function</span> <span class="pre">Outliers.&lt;lambda&gt;&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha=0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n=10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func=&lt;function</span> <span class="pre">sum&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iter_start=0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">partition=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">partition_min=11</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stray_range=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">drop_flagged=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thresh=3.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_periods=1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag=255.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.flagMVScores" title="Permalink to this definition">¶</a></dt>
<dd><p>The algorithm implements a 3-step outlier detection procedure for simultaneously
flagging of higher dimensional data (dimensions &gt; 3).</p>
<p>In references [1], the procedure is introduced and exemplified with an
application on hydrological data. See the notes section for an overview over the
algorithms basic steps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>field</strong> (<em>list of str</em>) – List of fieldnames, corresponding to the variables that are to be included
into the flagging process.</p>
</dd>
</dl>
<dl class="simple">
<dt>trafo<span class="classifier">callable, default lambda x:x</span></dt><dd><p>Transformation to be applied onto every column before scoring. Will likely
get deprecated soon. Its better to transform the data in a processing step,
preceeeding the call to <code class="docutils literal notranslate"><span class="pre">flagMVScores</span></code>.</p>
</dd>
<dt>alpha<span class="classifier">float, default 0.05</span></dt><dd><p>Level of significance by which it is tested, if an observations score might
be drawn from another distribution than the majority of the observation.</p>
</dd>
<dt>n<span class="classifier">int, default 10</span></dt><dd><p>Number of neighbors included in the scoring process for every datapoint.</p>
</dd>
<dt>func<span class="classifier">Callable[numpy.array, float], default np.sum</span></dt><dd><p>The function that maps the set of every points k-nearest neighbor distances
onto a certain scoring.</p>
</dd>
<dt>iter_start<span class="classifier">float, default 0.5</span></dt><dd><p>Float in [0,1] that determines which percentage of data is considered
“normal”. 0.5 results in the threshing algorithm to search only the upper 50
% of the scores for the cut off point. (See reference section for more
information)</p>
</dd>
<dt>partition<span class="classifier">{None, str, int}, default None</span></dt><dd><p>Only effective when <cite>threshing</cite> = ‘stray’. Determines the size of the data
partitions, the data is decomposed into. Each partition is checked seperately
for outliers. If a String is passed, it has to be an offset string and it
results in partitioning the data into parts of according temporal length. If
an integer is passed, the data is simply split up into continous chunks of
<cite>freq</cite> periods. if <code class="docutils literal notranslate"><span class="pre">None</span></code> is passed (default), all the data will be tested
in one run.</p>
</dd>
<dt>partition_min<span class="classifier">int, default 11</span></dt><dd><p>Only effective when <cite>threshing</cite> = ‘stray’. Minimum number of periods per
partition that have to be present for a valid outlier detection to be made in
this partition. (Only of effect, if <cite>stray_partition</cite> is an integer.)</p>
</dd>
<dt>partition_trafo<span class="classifier">bool, default True</span></dt><dd><p>Whether or not to apply the passed transformation on every partition the
algorithm is applied on, separately.</p>
</dd>
<dt>stray_range<span class="classifier">{None, str}, default None</span></dt><dd><p>If not None, it is tried to reduce the stray result onto single outlier
components of the input fields. An offset string, denoting the range of the
temporal surrounding to include into the MAD testing while trying to reduce
flags.</p>
</dd>
<dt>drop_flagged<span class="classifier">bool, default False</span></dt><dd><p>Only effective when <cite>range</cite> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>. Whether or not to drop flagged
values other than the value under test from the temporal surrounding before
checking the value with MAD.</p>
</dd>
<dt>thresh<span class="classifier">float, default 3.5</span></dt><dd><p>Only effective when <cite>range</cite> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>. The <cite>critical</cite> value,
controlling wheather the MAD score is considered referring to an outlier or
not. Higher values result in less rigid flagging. The default value is widely
considered apropriate in the literature.</p>
</dd>
<dt>min_periods<span class="classifier">int, 1</span></dt><dd><p>Only effective when <cite>range</cite> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>. Minimum number of meassurements
necessarily present in a reduction interval for reduction actually to be
performed.</p>
</dd>
<dt>flag<span class="classifier">float, default BAD</span></dt><dd><p>flag to set.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The basic steps are:</p>
<ol class="arabic simple">
<li><p>transforming</p></li>
</ol>
<p>The different data columns are transformed via timeseries transformations to
(a) make them comparable and
(b) make outliers more stand out.</p>
<p>This step is usually subject to a phase of research/try and error. See [1] for more
details.</p>
<p>Note, that the data transformation as an built-in step of the algorithm,
will likely get deprecated soon. Its better to transform the data in a processing
step, preceeding the multivariate flagging process. Also, by doing so, one gets
mutch more control and variety in the transformation applied, since the <cite>trafo</cite>
parameter only allows for application of the same transformation to all of the
variables involved.</p>
<ol class="arabic simple" start="2">
<li><p>scoring</p></li>
</ol>
<p>Every observation gets assigned a score depending on its k nearest neighbors. See
the <cite>scoring_method</cite> parameter description for details on the different scoring
methods. Furthermore [1], [2] may give some insight in the pro and cons of the
different methods.</p>
<ol class="arabic simple" start="3">
<li><p>threshing</p></li>
</ol>
<p>The gaps between the (greatest) scores are tested for beeing drawn from the same
distribution as the majority of the scores. If a gap is encountered, that,
with sufficient significance, can be said to not be drawn from the same
distribution as the one all the smaller gaps are drawn from, than the observation
belonging to this gap, and all the observations belonging to gaps larger then
this gap, get flagged outliers. See description of the <cite>threshing</cite> parameter for
more details. Although [2] gives a fully detailed overview over the <cite>stray</cite>
algorithm.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.flagManual">
<span class="sig-name descname"><span class="pre">flagManual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mdata</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'left-open'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mformat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'start-end'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mflag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">255.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.flagManual" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag data by given, “manually generated” data.</p>
<p>The data is flagged at locations where <cite>mdata</cite> is equal to a provided flag (<cite>mflag</cite>).
The format of mdata can be an indexed object, like pd.Series, pd.Dataframe or dios.DictOfSeries,
but also can be a plain list- or array-like.
How indexed mdata is aligned to data is specified via the <cite>method</cite> parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> (<em>str</em>) – The fieldname of the column, holding the data-to-be-flagged.</p></li>
<li><p><strong>mdata</strong> (<em>pd.Series</em><em>, </em><em>pd.DataFrame</em><em>, </em><em>DictOfSeries</em><em>, </em><em>str</em><em>, </em><em>list</em><em> or </em><em>np.ndarray</em>) – The Data determining, wich intervals are to be flagged, or a string, denoting under which field the data is
accessable.</p></li>
<li><p><strong>method</strong> (<em>{'plain'</em><em>, </em><em>'ontime'</em><em>, </em><em>'left-open'</em><em>, </em><em>'right-open'</em><em>, </em><em>'closed'}</em><em>, </em><em>default 'plain'</em>) – <p>Defines how mdata is projected on data. Except for the ‘plain’ method, the methods assume mdata to have an
index.</p>
<ul>
<li><p>’plain’: mdata must have the same length as data and is projected one-to-one on data.</p></li>
<li><p>’ontime’: works only with indexed mdata. mdata entries are matched with data entries that have the same index.</p></li>
<li><p>’right-open’: mdata defines intervals, values are to be projected on.
The intervals are defined,</p>
<ol class="arabic simple">
<li><p>Either, by any two consecutive timestamps t_1 and 1_2 where t_1 is valued with mflag, or by a series,</p></li>
<li><p>Or, a Series, where the index contains in the t1 timestamps nd the values the respective t2 stamps.</p></li>
</ol>
<p>The value at t_1 gets projected onto all data timestamps t with t_1 &lt;= t &lt; t_2.</p>
</li>
<li><p>’left-open’: like ‘right-open’, but the projected interval now covers all t with t_1 &lt; t &lt;= t_2.</p></li>
<li><p>’closed’: like ‘right-open’, but the projected interval now covers all t with t_1 &lt;= t &lt;= t_2.</p></li>
</ul>
</p></li>
<li><p><strong>mformat</strong> (<em>{&quot;start-end&quot;</em><em>, </em><em>&quot;mflag&quot;}</em><em>, </em><em>default &quot;start-end&quot;</em>) – <ul>
<li><p>“start-end”: mdata is a Series, where every entry indicates an interval to-flag. The index defines the left
bound, the value defines the right bound.</p></li>
<li><p>”mflag”: mdata is an array like, with entries containing ‘mflag’,where flags shall be set. See documentation
for examples.</p></li>
</ul>
</p></li>
<li><p><strong>mflag</strong> (<em>scalar</em>) – The flag that indicates data points in <cite>mdata</cite>, of wich the projection in data should be flagged.</p></li>
<li><p><strong>flag</strong> (<em>float</em><em>, </em><em>default BAD</em>) – flag to set.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>An example for mdata</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mdata</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">([</span><span class="s1">&#39;2000-02-01&#39;</span><span class="p">,</span> <span class="s1">&#39;2000-03-01&#39;</span><span class="p">,</span> <span class="s1">&#39;2000-05-01&#39;</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mdata</span>
<span class="go">2000-02-01    1</span>
<span class="go">2000-03-01    0</span>
<span class="go">2000-05-01    1</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>On <em>dayly</em> data, with the ‘ontime’ method, only the provided timestamps are used.
Bear in mind that only exact timestamps apply, any offset will result in ignoring
the timestamp.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">([</span><span class="s1">&#39;2000-01-31&#39;</span><span class="p">,</span> <span class="s1">&#39;2000-02-01&#39;</span><span class="p">,</span> <span class="s1">&#39;2000-02-02&#39;</span><span class="p">,</span> <span class="s1">&#39;2000-03-01&#39;</span><span class="p">,</span> <span class="s1">&#39;2000-05-01&#39;</span><span class="p">]),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;daily_data&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span> <span class="o">=</span> <span class="n">saqc</span><span class="o">.</span><span class="n">SaQC</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">flagManual</span><span class="p">(</span><span class="s1">&#39;daily_data&#39;</span><span class="p">,</span> <span class="n">mdata</span><span class="p">,</span> <span class="n">mflag</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mformat</span><span class="o">=</span><span class="s1">&#39;mdata&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;ontime&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s1">&#39;daily_data&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">UNFLAGGED</span>
<span class="go">2000-01-31    False</span>
<span class="go">2000-02-01     True</span>
<span class="go">2000-02-02    False</span>
<span class="go">2000-03-01    False</span>
<span class="go">2000-05-01     True</span>
<span class="go">Name: daily_data, dtype: bool</span>
</pre></div>
</div>
<p>With the ‘right-open’ method, the mdata is forward fill:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">flagManual</span><span class="p">(</span><span class="s1">&#39;daily_data&#39;</span><span class="p">,</span> <span class="n">mdata</span><span class="p">,</span> <span class="n">mflag</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mformat</span><span class="o">=</span><span class="s1">&#39;mdata&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;right-open&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s1">&#39;daily_data&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">UNFLAGGED</span>
<span class="go">2000-01-31    False</span>
<span class="go">2000-02-01     True</span>
<span class="go">2000-02-02     True</span>
<span class="go">2000-03-01    False</span>
<span class="go">2000-05-01     True</span>
<span class="go">Name: daily_data, dtype: bool</span>
</pre></div>
</div>
<p>With the ‘left-open’ method, backward filling is used:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">flagManual</span><span class="p">(</span><span class="s1">&#39;daily_data&#39;</span><span class="p">,</span> <span class="n">mdata</span><span class="p">,</span> <span class="n">mflag</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mformat</span><span class="o">=</span><span class="s1">&#39;mdata&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;left-open&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s1">&#39;daily_data&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">UNFLAGGED</span>
<span class="go">2000-01-31    False</span>
<span class="go">2000-02-01     True</span>
<span class="go">2000-02-02     True</span>
<span class="go">2000-03-01     True</span>
<span class="go">2000-05-01     True</span>
<span class="go">Name: daily_data, dtype: bool</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.flagMissing">
<span class="sig-name descname"><span class="pre">flagMissing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">255.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dfilter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">inf</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.flagMissing" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag NaNs in data.</p>
<p>By default only NaNs are flagged, that not already have a flag.
<cite>to_mask</cite> can be used to pass a flag that is used as threshold.
Each flag worse than the threshold is replaced by the function.
This is, because the data gets masked (with NaNs) before the
function evaluates the NaNs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>field</strong> (<em>str</em>) – Column(s) in flags and data.</p>
</dd>
</dl>
<dl class="simple">
<dt>flag<span class="classifier">float, default BAD</span></dt><dd><p>Flag to set.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.flagOffset">
<span class="sig-name descname"><span class="pre">flagOffset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thresh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thresh_relative</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">255.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.flagOffset" title="Permalink to this definition">¶</a></dt>
<dd><p>A basic outlier test that works on regularly and irregularly sampled data.</p>
<p>The test classifies values/value courses as outliers by detecting not only a rise
in value, but also, by checking for a return to the initial value level.</p>
<p>Values <span class="math notranslate nohighlight">\(x_n, x_{n+1}, .... , x_{n+k}\)</span> of a timeseries <span class="math notranslate nohighlight">\(x\)</span> with
associated timestamps <span class="math notranslate nohighlight">\(t_n, t_{n+1}, .... , t_{n+k}\)</span> are considered spikes, if</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(|x_{n-1} - x_{n + s}| &gt;\)</span> <cite>thresh</cite>, for all <span class="math notranslate nohighlight">\(s \in [0,1,2,...,k]\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\((x_{n + s} - x_{n - 1}) / x_{n - 1} &gt;\)</span> <cite>thresh_relative</cite></p></li>
<li><p><span class="math notranslate nohighlight">\(|x_{n-1} - x_{n+k+1}| &lt;\)</span> <cite>tolerance</cite></p></li>
<li><p><span class="math notranslate nohighlight">\(|t_{n-1} - t_{n+k+1}| &lt;\)</span> <cite>window</cite></p></li>
</ol>
<p>Note, that this definition of a “spike” not only includes one-value outliers, but
also plateau-ish value courses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> (<em>str</em>) – The field in data.</p></li>
<li><p><strong>tolerance</strong> (<em>float</em>) – Maximum difference allowed, between the value, directly preceding and the value, directly succeeding an offset,
to trigger flagging of the values forming the offset.
See condition (3).</p></li>
<li><p><strong>window</strong> (<em>{str</em><em>, </em><em>int}</em><em>, </em><em>default '15min'</em>) – Maximum length allowed for offset value courses, to trigger flagging of the values forming the offset.
See condition (4). Integer defined window length are only allowed for regularly sampled timeseries.</p></li>
<li><p><strong>thresh</strong> (<em>float: {float</em><em>, </em><em>None}</em><em>, </em><em>default None</em>) – Minimum difference between a value and its successors, to consider the successors an anomalous offset group.
See condition (1). If None is passed, condition (1) is not tested.</p></li>
<li><p><strong>thresh_relative</strong> (<em>{float</em><em>, </em><em>None}</em><em>, </em><em>default None</em>) – Minimum relative change between and its successors, to consider the successors an anomalous offset group.
See condition (2). If None is passed, condition (2) is not tested.</p></li>
<li><p><strong>flag</strong> (<em>float</em><em>, </em><em>default BAD</em>) – flag to set.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Lets generate a simple, regularly sampled timeseries with an hourly sampling rate and generate an
<a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-class docutils literal notranslate"><span class="pre">saqc.SaQC</span></code></a> instance from it.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;data&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">])},</span> <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;2000&#39;</span><span class="p">,</span><span class="n">freq</span><span class="o">=</span><span class="s1">&#39;1H&#39;</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">12</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">                     data</span>
<span class="go">2000-01-01 00:00:00     5</span>
<span class="go">2000-01-01 01:00:00     5</span>
<span class="go">2000-01-01 02:00:00     8</span>
<span class="go">2000-01-01 03:00:00    16</span>
<span class="go">2000-01-01 04:00:00    17</span>
<span class="go">2000-01-01 05:00:00     7</span>
<span class="go">2000-01-01 06:00:00     4</span>
<span class="go">2000-01-01 07:00:00     4</span>
<span class="go">2000-01-01 08:00:00     4</span>
<span class="go">2000-01-01 09:00:00     1</span>
<span class="go">2000-01-01 10:00:00     1</span>
<span class="go">2000-01-01 11:00:00     4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span> <span class="o">=</span> <span class="n">saqc</span><span class="o">.</span><span class="n">SaQC</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we are applying <a class="reference internal" href="#saqc.SaQC.flagOffset" title="saqc.SaQC.flagOffset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">flagOffset()</span></code></a> and try to flag offset courses, that dont extend longer than
<em>6 hours</em> in time (<code class="docutils literal notranslate"><span class="pre">window</span></code>) and that have an initial value jump higher than <em>2</em> (<code class="docutils literal notranslate"><span class="pre">thresh</span></code>), and that do return
to the initial value level within a tolerance of <em>1.5</em> (<code class="docutils literal notranslate"><span class="pre">tolerance</span></code>).</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">flagOffset</span><span class="p">(</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;6H&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">)</span> 
</pre></div>
</div>
<figure class="align-default">
<img alt="../_images/saqc-SaQC-2.png" class="plot-directive" src="../_images/saqc-SaQC-2.png" />
</figure>
<p>Note, that both, negative and positive jumps are considered starting points of negative or positive offsets.
If you want to impose the additional condition, that the initial value jump must exceed <em>+90%</em> of the value level,
you can additionally set the <code class="docutils literal notranslate"><span class="pre">thresh_relative</span></code> parameter:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">flagOffset</span><span class="p">(</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">thresh_relative</span><span class="o">=</span><span class="mf">.9</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;6H&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">)</span> 
</pre></div>
</div>
<figure class="align-default">
<img alt="../_images/saqc-SaQC-3.png" class="plot-directive" src="../_images/saqc-SaQC-3.png" />
</figure>
<p>Now, only positive jumps, that exceed a value gain of <em>+90%</em> are considered starting points of offsets.</p>
<p>In the same way, you can aim for only negative offsets, by setting a negative relative threshold. The below
example only flags offsets, that fall off by at least <em>50 %</em> in value, with an absolute value drop of at least <em>2</em>.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">flagOffset</span><span class="p">(</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">thresh_relative</span><span class="o">=-</span><span class="mf">.5</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;6H&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">)</span> 
</pre></div>
</div>
<figure class="align-default">
<img alt="../_images/saqc-SaQC-4.png" class="plot-directive" src="../_images/saqc-SaQC-4.png" />
</figure>
<p class="rubric">References</p>
<p>The implementation is a time-window based version of an outlier test from the UFZ Python library,
that can be found here:</p>
<p><a class="reference external" href="https://git.ufz.de/chs/python/blob/master/ufz/level1/spike.py">https://git.ufz.de/chs/python/blob/master/ufz/level1/spike.py</a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.flagPatternByDTW">
<span class="sig-name descname"><span class="pre">flagPatternByDTW</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_distance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">255.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.flagPatternByDTW" title="Permalink to this definition">¶</a></dt>
<dd><p>Pattern Recognition via Dynamic Time Warping.</p>
<p>The steps are:
1. work on a moving window</p>
<ol class="arabic simple" start="2">
<li><p>for each data chunk extracted from each window, a distance to the given pattern
is calculated, by the dynamic time warping algorithm [1]</p></li>
<li><p>if the distance is below the threshold, all the data in the window gets flagged</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>field</strong> (<em>str</em>) – The name of the data column</p>
</dd>
</dl>
<dl class="simple">
<dt>reference<span class="classifier">str</span></dt><dd><p>The name in <cite>data</cite> which holds the pattern. The pattern must not have NaNs,
have a datetime index and must not be empty.</p>
</dd>
<dt>max_distance<span class="classifier">float, default 0.0</span></dt><dd><p>Maximum dtw-distance between chunk and pattern, if the distance is lower than
<code class="docutils literal notranslate"><span class="pre">max_distance</span></code> the data gets flagged. With default, <code class="docutils literal notranslate"><span class="pre">0.0</span></code>, only exact
matches are flagged.</p>
</dd>
<dt>normalize<span class="classifier">bool, default True</span></dt><dd><p>If <cite>False</cite>, return unmodified distances.
If <cite>True</cite>, normalize distances by the number of observations of the reference.
This helps to make it easier to find a good cutoff threshold for further
processing. The distances then refer to the mean distance per datapoint,
expressed in the datas units.</p>
</dd>
<dt>plot: bool, default False</dt><dd><p>Show a calibration plot, which can be quite helpful to find the right threshold
for <cite>max_distance</cite>. It works best with <cite>normalize=True</cite>. Do not use in automatic
setups / pipelines. The plot show three lines:</p>
<ul class="simple">
<li><p>data: the data the function was called on</p></li>
<li><p>distances: the calculated distances by the algorithm</p></li>
<li><p>indicator: have to distinct levels: <cite>0</cite> and the value of <cite>max_distance</cite>.
If <cite>max_distance</cite> is <cite>0.0</cite> it defaults to <cite>1</cite>. Everywhere where the
indicator is not <cite>0</cite> the data will be flagged.</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The window size of the moving window is set to equal the temporal extension of the
reference datas datetime index.</p>
<p class="rubric">References</p>
<p>Find a nice description of underlying the Dynamic Time Warping Algorithm here:</p>
<p>[1] <a class="reference external" href="https://cran.r-project.org/web/packages/dtw/dtw.pdf">https://cran.r-project.org/web/packages/dtw/dtw.pdf</a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.flagRaise">
<span class="sig-name descname"><span class="pre">flagRaise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thresh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">raise_window</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">average_window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">raise_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">255.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.flagRaise" title="Permalink to this definition">¶</a></dt>
<dd><p>The function flags raises and drops in value courses, that exceed a certain threshold
within a certain timespan.</p>
<p>The parameter variety of the function is owned to the intriguing
case of values, that “return” from outlierish or anomalious value levels and
thus exceed the threshold, while actually being usual values.</p>
<p>NOTE, the dataset is NOT supposed to be harmonized to a time series with an
equidistant frequency grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> (<em>str</em>) – The fieldname of the column, holding the data-to-be-flagged.</p></li>
<li><p><strong>thresh</strong> (<em>float</em>) – The threshold, for the total rise (thresh &gt; 0), or total drop (thresh &lt; 0),
value courses must not exceed within a timespan of length <cite>raise_window</cite>.</p></li>
<li><p><strong>raise_window</strong> (<em>str</em>) – An offset string, determining the timespan, the rise/drop thresholding refers
to. Window is inclusively defined.</p></li>
<li><p><strong>freq</strong> (<em>str</em>) – An offset string, determining The frequency, the timeseries to-be-flagged is
supposed to be sampled at. The window is inclusively defined.</p></li>
<li><p><strong>average_window</strong> (<em>{None</em><em>, </em><em>str}</em><em>, </em><em>default None</em>) – See condition (2) of the description linked in the references. Window is
inclusively defined. The window defaults to 1.5 times the size of <cite>raise_window</cite></p></li>
<li><p><strong>raise_factor</strong> (<em>float</em><em>, </em><em>default 2</em>) – See second condition listed in the notes below.</p></li>
<li><p><strong>slope</strong> (<em>{None</em><em>, </em><em>float}</em><em>, </em><em>default None</em>) – See third condition listed in the notes below.</p></li>
<li><p><strong>weight</strong> (<em>float</em><em>, </em><em>default 0.8</em>) – See third condition listed in the notes below.</p></li>
<li><p><strong>flag</strong> (<em>float</em><em>, </em><em>default BAD</em>) – flag to set.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The value <span class="math notranslate nohighlight">\(x_{k}\)</span> of a time series <span class="math notranslate nohighlight">\(x\)</span> with associated
timestamps <span class="math notranslate nohighlight">\(t_i\)</span>, is flagged a raise, if:</p>
<ul class="simple">
<li><p>There is any value <span class="math notranslate nohighlight">\(x_{s}\)</span>, preceeding <span class="math notranslate nohighlight">\(x_{k}\)</span> within <cite>raise_window</cite>
range, so that:</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(M = |x_k - x_s | &gt;\)</span>  <cite>thresh</cite> <span class="math notranslate nohighlight">\(&gt; 0\)</span></p></li>
</ul>
</li>
<li><p>The weighted average <span class="math notranslate nohighlight">\(\mu^{*}\)</span> of the values, preceding <span class="math notranslate nohighlight">\(x_{k}\)</span>
within <cite>average_window</cite>
range indicates, that <span class="math notranslate nohighlight">\(x_{k}\)</span> does not return from an “outlierish” value
course, meaning that:</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(x_k &gt; \mu^* + ( M\)</span> / <cite>mean_raise_factor</cite> <span class="math notranslate nohighlight">\()\)</span></p></li>
</ul>
</li>
<li><p>Additionally, if <code class="docutils literal notranslate"><span class="pre">min_slope</span></code> is not <cite>None</cite>, <span class="math notranslate nohighlight">\(x_{k}\)</span> is checked for being
sufficiently divergent from its very predecessor <span class="math notranslate nohighlight">\(x_{k-1}\)</span>, meaning that, it
is additionally checked if:</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(x_k - x_{k-1} &gt;\)</span> <cite>min_slope</cite></p></li>
<li><p><span class="math notranslate nohighlight">\(t_k - t_{k-1} &gt;\)</span> <cite>weight</cite> <span class="math notranslate nohighlight">\(\times\)</span> <cite>freq</cite></p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.flagRange">
<span class="sig-name descname"><span class="pre">flagRange</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">255.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.flagRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Function flags values not covered by the closed interval [<cite>min</cite>, <cite>max</cite>].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> (<em>str</em>) – The fieldname of the column, holding the data-to-be-flagged.</p></li>
<li><p><strong>min</strong> (<em>float</em>) – Lower bound for valid data.</p></li>
<li><p><strong>max</strong> (<em>float</em>) – Upper bound for valid data.</p></li>
<li><p><strong>flag</strong> (<em>float</em><em>, </em><em>default BAD</em>) – flag to set.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.flagRegimeAnomaly">
<span class="sig-name descname"><span class="pre">flagRegimeAnomaly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cluster_field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spread</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method='single'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric=&lt;function</span> <span class="pre">Drift.&lt;lambda&gt;&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frac=0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag=255.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.flagRegimeAnomaly" title="Permalink to this definition">¶</a></dt>
<dd><p>Flags anomalous regimes regarding to modelling regimes of field.</p>
<p>“Normality” is determined in terms of a maximum spreading distance,
regimes must not exceed in respect to a certain metric and linkage method.</p>
<p>In addition, only a range of regimes is considered “normal”, if it models
more then <cite>frac</cite> percentage of the valid samples in “field”.</p>
<p>Note, that you must detect the regime changepoints prior to calling this function.</p>
<p>Note, that it is possible to perform hypothesis tests for regime equality
by passing the metric a function for p-value calculation and selecting linkage
method “complete”.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> (<em>str</em>) – Name of the column to process</p></li>
<li><p><strong>cluster_field</strong> (<em>str</em>) – Column in data, holding the cluster labels for the samples in field.
(has to be indexed equal to field)</p></li>
<li><p><strong>spread</strong> (<em>float</em>) – A threshold denoting the value level, up to wich clusters a agglomerated.</p></li>
<li><p><strong>method</strong> (<em>{&quot;single&quot;</em><em>, </em><em>&quot;complete&quot;</em><em>, </em><em>&quot;average&quot;</em><em>, </em><em>&quot;weighted&quot;</em><em>, </em><em>&quot;centroid&quot;</em><em>, </em><em>&quot;median&quot;</em><em>, </em><em>&quot;ward&quot;}</em><em>, </em><em>default &quot;single&quot;</em>) – The linkage method for hierarchical (agglomerative) clustering of the variables.</p></li>
<li><p><strong>metric</strong> (<em>Callable</em><em>, </em><em>default lambda x</em><em>,</em><em>y: np.abs</em><em>(</em><em>np.nanmean</em><em>(</em><em>x</em><em>) </em><em>- np.nanmean</em><em>(</em><em>y</em><em>)</em><em>)</em>) – A metric function for calculating the dissimilarity between 2 regimes.
Defaults to the difference in mean.</p></li>
<li><p><strong>frac</strong> (<em>float</em>) – Has to be in [0,1]. Determines the minimum percentage of samples,
the “normal” group has to comprise to be the normal group actually.</p></li>
<li><p><strong>flag</strong> (<em>float</em><em>, </em><em>default BAD</em>) – flag to set.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.flagUnflagged">
<span class="sig-name descname"><span class="pre">flagUnflagged</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">255.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.flagUnflagged" title="Permalink to this definition">¶</a></dt>
<dd><p>Function sets a flag at all unflagged positions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> (<em>str</em>) – The fieldname of the column, holding the data-to-be-flagged.</p></li>
<li><p><strong>flag</strong> (<em>float</em><em>, </em><em>default BAD</em>) – flag value to set</p></li>
<li><p><strong>kwargs</strong> (<em>Dict</em>) – unused</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function ignores the <code class="docutils literal notranslate"><span class="pre">dfilter</span></code> keyword, because the data is not relevant
for processing.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.forceFlags">
<span class="sig-name descname"><span class="pre">forceFlags</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">255.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.forceFlags" title="Permalink to this definition">¶</a></dt>
<dd><p>Set whole column to a flag value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> (<em>str</em>) – columns name that holds the data</p></li>
<li><p><strong>flag</strong> (<em>float</em><em>, </em><em>default BAD</em>) – flag to set</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) – unused</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.interpolate">
<span class="sig-name descname"><span class="pre">interpolate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>A method to “regularize” data by interpolating the data at regular timestamp.</p>
<p>A series of data is considered “regular”, if it is sampled regularly (= having uniform sampling rate).</p>
<p>Interpolated values will get assigned the worst flag within freq-range.</p>
<p>There are available all the interpolations from the pandas.Series.interpolate method and they are called by
the very same keywords.</p>
<p>Note, that, to perform a timestamp aware, linear interpolation, you have to pass <code class="docutils literal notranslate"><span class="pre">'time'</span></code> as <cite>method</cite>,
and NOT <code class="docutils literal notranslate"><span class="pre">'linear'</span></code>.</p>
<p>Note, that the data only gets interpolated at those (regular) timestamps, that have a valid (existing and
not-na) datapoint preceeding them and one succeeding them within freq range.
Regular timestamp that do not suffice this condition get nan assigned AND The associated flag will be of value
<code class="docutils literal notranslate"><span class="pre">UNFLAGGED</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>field</strong> (<em>str</em>) – The fieldname of the column, holding the data-to-be-regularized.</p>
</dd>
</dl>
<dl class="simple">
<dt>freq<span class="classifier">str</span></dt><dd><p>An offset string. The frequency of the grid you want to interpolate your data at.</p>
</dd>
<dt>method<span class="classifier">{“linear”, “time”, “nearest”, “zero”, “slinear”, “quadratic”, “cubic”, “spline”, “barycentric”,</span></dt><dd><p>“polynomial”, “krogh”, “piecewise_polynomial”, “spline”, “pchip”, “akima”}
The interpolation method you want to apply.</p>
</dd>
<dt>order<span class="classifier">int, default 1</span></dt><dd><p>If your selected interpolation method can be performed at different <em>orders</em> - here you pass the desired
order.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.interpolateByRolling">
<span class="sig-name descname"><span class="pre">interpolateByRolling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func=&lt;function</span> <span class="pre">median&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_periods=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag=-inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.interpolateByRolling" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolates nan-values in the data by assigning them the aggregation result of the window surrounding them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>field</strong> (<em>str</em>) – Name of the column, holding the data-to-be-interpolated.</p>
</dd>
</dl>
<dl class="simple">
<dt>window<span class="classifier">int, str</span></dt><dd><p>The size of the window, the aggregation is computed from. An integer define the number of periods to be used,
an string is interpreted as an offset. ( see <cite>pandas.rolling</cite> for more information).
Integer windows may result in screwed aggregations if called on none-harmonized or irregular data.</p>
</dd>
<dt>func<span class="classifier">Callable</span></dt><dd><p>The function used for aggregation.</p>
</dd>
<dt>center<span class="classifier">bool, default True</span></dt><dd><p>Center the window around the value. Can only be used with integer windows, otherwise it is silently ignored.</p>
</dd>
<dt>min_periods<span class="classifier">int</span></dt><dd><p>Minimum number of valid (not np.nan) values that have to be available in a window for its aggregation to be
computed.</p>
</dd>
<dt>flag<span class="classifier">float or None, default UNFLAGGED</span></dt><dd><p>Flag that is to be inserted for the interpolated values.
If <cite>None</cite> the old flags are kept, even if the data is valid now.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.interpolateIndex">
<span class="sig-name descname"><span class="pre">interpolateIndex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">downgrade</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.interpolateIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to interpolate the data at regular (equidistant) timestamps (or Grid points).</p>
<p>Note, that the interpolation will only be calculated, for grid timestamps that have a preceding AND a succeeding
valid data value within “freq” range.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>field</strong> (<em>str</em>) – Name of the column, holding the data-to-be-interpolated.</p>
</dd>
</dl>
<dl class="simple">
<dt>freq<span class="classifier">str</span></dt><dd><p>An Offset String, interpreted as the frequency of
the grid you want to interpolate your data at.</p>
</dd>
<dt>method<span class="classifier">{“linear”, “time”, “nearest”, “zero”, “slinear”, “quadratic”, “cubic”, “spline”, “barycentric”,</span></dt><dd><p>“polynomial”, “krogh”, “piecewise_polynomial”, “spline”, “pchip”, “akima”}: string
The interpolation method you want to apply.</p>
</dd>
<dt>order<span class="classifier">int, default 2</span></dt><dd><p>If there your selected interpolation method can be performed at different ‘orders’ - here you pass the desired
order.</p>
</dd>
<dt>limit<span class="classifier">int, default 2</span></dt><dd><p>Maximum number of consecutive ‘nan’ values allowed for a gap to be interpolated. This really restricts the
interpolation to chunks, containing not more than <cite>limit</cite> successive nan entries.</p>
</dd>
<dt>downgrade<span class="classifier">bool, default False</span></dt><dd><p>If <cite>True</cite> and the interpolation can not be performed at current order, retry with a lower order.
This can happen, because the chosen <code class="docutils literal notranslate"><span class="pre">method</span></code> does not support the passed <code class="docutils literal notranslate"><span class="pre">order</span></code>, or
simply because not enough values are present in a interval.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.interpolateInvalid">
<span class="sig-name descname"><span class="pre">interpolateInvalid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">downgrade</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">inf</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.interpolateInvalid" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to interpolate nan values in the data.</p>
<p>There are available all the interpolation methods from the pandas.interpolate method and they are applicable by
the very same key words, that you would pass to the <code class="docutils literal notranslate"><span class="pre">pd.Series.interpolate</span></code>’s method parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>field</strong> (<em>str</em>) – Name of the column, holding the data-to-be-interpolated.</p>
</dd>
</dl>
<dl class="simple">
<dt>method<span class="classifier">{“linear”, “time”, “nearest”, “zero”, “slinear”, “quadratic”, “cubic”, “spline”, “barycentric”,</span></dt><dd><p>“polynomial”, “krogh”, “piecewise_polynomial”, “spline”, “pchip”, “akima”}
The interpolation method to use.</p>
</dd>
<dt>order<span class="classifier">int, default 2</span></dt><dd><p>If there your selected interpolation method can be performed at different ‘orders’ - here you pass the desired
order.</p>
</dd>
<dt>limit<span class="classifier">int, default 2</span></dt><dd><p>Maximum number of consecutive ‘nan’ values allowed for a gap to be interpolated. This really restricts the
interpolation to chunks, containing not more than <cite>limit</cite> successive nan entries.</p>
</dd>
<dt>flag<span class="classifier">float or None, default UNFLAGGED</span></dt><dd><p>Flag that is set for interpolated values. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, no flags are set at all.</p>
</dd>
<dt>downgrade<span class="classifier">bool, default False</span></dt><dd><p>If <cite>True</cite> and the interpolation can not be performed at current order, retry with a lower order.
This can happen, because the chosen <code class="docutils literal notranslate"><span class="pre">method</span></code> does not support the passed <code class="docutils literal notranslate"><span class="pre">order</span></code>, or
simply because not enough values are present in a interval.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.linear">
<span class="sig-name descname"><span class="pre">linear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.linear" title="Permalink to this definition">¶</a></dt>
<dd><p>A method to “regularize” data by interpolating linearly the data at regular timestamp.</p>
<p>A series of data is considered “regular”, if it is sampled regularly (= having uniform sampling rate).</p>
<p>Interpolated values will get assigned the worst flag within freq-range.</p>
<p>Note, that the data only gets interpolated at those (regular) timestamps, that have a valid (existing and
not-na) datapoint preceeding them and one succeeding them within freq range.
Regular timestamp that do not suffice this condition get nan assigned AND The associated flag will be of value
<code class="docutils literal notranslate"><span class="pre">UNFLAGGED</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>field</strong> (<em>str</em>) – The fieldname of the column, holding the data-to-be-regularized.</p>
</dd>
</dl>
<dl class="simple">
<dt>freq<span class="classifier">str</span></dt><dd><p>An offset string. The frequency of the grid you want to interpolate your data at.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.plot">
<span class="sig-name descname"><span class="pre">plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_gap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">history</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'valid'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xscope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phaseplot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">store_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dfilter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot data and flags or store plot to file.</p>
<p>There are two modes, ‘interactive’ and ‘store’, which are determind through the
<code class="docutils literal notranslate"><span class="pre">save_path</span></code> keyword. In interactive mode (default) the plot is shown at runtime
and the program execution stops until the plot window is closed manually. In
store mode the generated plot is stored to disk and no manually interaction is
needed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>field</strong> (<em>str</em>) – Name of the variable-to-plot</p>
</dd>
</dl>
<dl class="simple">
<dt>path<span class="classifier">str, default None</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">None</span></code> is passed, interactive mode is entered; plots are shown immediatly
and a user need to close them manually before execution continues.
If a filepath is passed instead, store-mode is entered and
the plot is stored unter the passed location.</p>
</dd>
<dt>max_gap<span class="classifier">str, default None</span></dt><dd><p>If None, all the points in the data will be connected, resulting in long linear
lines, where continous chunks of data is missing. Nans in the data get dropped
before plotting. If an offset string is passed, only points that have a distance
below <cite>max_gap</cite> get connected via the plotting line.</p>
</dd>
<dt>history<span class="classifier">{“valid”, “complete”, None, list of strings}, default “valid”</span></dt><dd><p>Discriminate the plotted flags with respect to the tests they originate from.</p>
<ul class="simple">
<li><p>“valid” - Only plot those flags, that do not get altered or “unflagged” by subsequent tests. Only list tests
in the legend, that actually contributed flags to the overall resault.</p></li>
<li><p>“complete” - plot all the flags set and list all the tests ran on a variable. Suitable for debugging/tracking.</p></li>
<li><p>None - just plot the resulting flags for one variable, without any historical meta information.</p></li>
<li><p>list of strings - plot only flags set by those tests listed.</p></li>
</ul>
</dd>
<dt>xscope<span class="classifier">slice or Offset, default None</span></dt><dd><p>Parameter, that determines a chunk of the data to be plotted
processed. <cite>xscope</cite> can be anything, that is a valid argument to the <code class="docutils literal notranslate"><span class="pre">pandas.Series.__getitem__</span></code> method.</p>
</dd>
<dt>phaseplot<span class="classifier">str or None, default None</span></dt><dd><p>If a string is passed, plot <code class="docutils literal notranslate"><span class="pre">field</span></code> in the phase space it forms together with the Variable <code class="docutils literal notranslate"><span class="pre">phaseplot</span></code>.</p>
</dd>
<dt>store_kwargs<span class="classifier">dict, default {}</span></dt><dd><p>Keywords to be passed on to the <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot.savefig</span></code> method, handling
the figure storing. To store an pickle object of the figure, use the option
<code class="docutils literal notranslate"><span class="pre">{'pickle':</span> <span class="pre">True}</span></code>, but note that all other store_kwargs are ignored then.
Reopen with: <code class="docutils literal notranslate"><span class="pre">pickle.load(open(savepath,'w')).show()</span></code></p>
</dd>
<dt>ax_kwargs<span class="classifier">dict, default {}</span></dt><dd><p>Axis keywords. Change the axis labeling defaults. Most important keywords:
‘x_label’, ‘y_label’, ‘title’, ‘fontsize’, ‘cycleskip’.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.processGeneric">
<span class="sig-name descname"><span class="pre">processGeneric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dfilter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">inf</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.processGeneric" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate/process data with user defined functions.</p>
<p>Formally, what the function does, is the following:</p>
<ol class="arabic simple">
<li><p>Let F be a Callable, depending on fields f_1, f_2,…f_K, (F = F(f_1, f_2,…f_K))
Than, for every timestamp t_i that occurs in at least one of the timeseries data[f_j] (outer join),
The value v_i is computed via:
v_i = data([f_1][t_i], data[f_2][t_i], …, data[f_K][t_i]), if all data[f_j][t_i] do exist
v_i = <code class="docutils literal notranslate"><span class="pre">np.nan</span></code>, if at least one of the data[f_j][t_i] is missing.</p></li>
<li><p>The result is stored to <code class="docutils literal notranslate"><span class="pre">data[target]</span></code>, if <code class="docutils literal notranslate"><span class="pre">target</span></code> is given or to <code class="docutils literal notranslate"><span class="pre">data[field]</span></code> otherwise</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> (<em>str</em><em> or </em><em>list of str</em>) – The variable(s) passed to func.</p></li>
<li><p><strong>func</strong> (<em>callable</em>) – Function to call on the variables given in <code class="docutils literal notranslate"><span class="pre">field</span></code>. The return value will be written
to <code class="docutils literal notranslate"><span class="pre">target</span></code> or <code class="docutils literal notranslate"><span class="pre">field</span></code> if the former is not given. This implies, that the function
needs to accept the same number of arguments (of type pandas.Series) as variables given
in <code class="docutils literal notranslate"><span class="pre">field</span></code> and should return an iterable of array-like objects with the same number
of elements as given in <code class="docutils literal notranslate"><span class="pre">target</span></code> (or <code class="docutils literal notranslate"><span class="pre">field</span></code> if <code class="docutils literal notranslate"><span class="pre">target</span></code> is not specified).</p></li>
<li><p><strong>target</strong> (<em>str</em><em> or </em><em>list of str</em>) – The variable(s) to write the result of <code class="docutils literal notranslate"><span class="pre">func</span></code> to. If not given, the variable(s)
specified in <code class="docutils literal notranslate"><span class="pre">field</span></code> will be overwritten. If a <code class="docutils literal notranslate"><span class="pre">target</span></code> is not given, it will be
created.</p></li>
<li><p><strong>flag</strong> (float, default <code class="docutils literal notranslate"><span class="pre">np.nan</span></code>) – The quality flag to set. The default <code class="docutils literal notranslate"><span class="pre">np.nan</span></code> states the general idea, that
<code class="docutils literal notranslate"><span class="pre">processGeneric</span></code> generates ‘new’ data without any flags.</p></li>
<li><p><strong>dfilter</strong> (float, default <code class="docutils literal notranslate"><span class="pre">FILTER_ALL</span></code>) – Threshold flag. Flag values greater than <code class="docutils literal notranslate"><span class="pre">dfilter</span></code> indicate that the associated
data value is inappropiate for further usage.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Compute the sum of the variables ‘rainfall’ and ‘snowfall’ and save the result to
a (new) variable ‘precipitation’</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">saqc</span> <span class="kn">import</span> <span class="n">SaQC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span> <span class="o">=</span> <span class="n">SaQC</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;rainfall&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;snowfall&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">]},</span> <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">([</span><span class="mi">0</span><span class="p">])))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">processGeneric</span><span class="p">(</span><span class="n">field</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;rainfall&quot;</span><span class="p">,</span> <span class="s2">&quot;snowfall&quot;</span><span class="p">],</span> <span class="n">target</span><span class="o">=</span><span class="s2">&quot;precipitation&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">to_df</span><span class="p">()</span>
<span class="go">columns     rainfall  snowfall  precipitation</span>
<span class="go">1970-01-01         1         2              3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.propagateFlags">
<span class="sig-name descname"><span class="pre">propagateFlags</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ffill'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">255.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dfilter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">inf</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.propagateFlags" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag values before or after flags set by the last test.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> (<em>str</em>) – The fieldname of the column, holding the data-to-be-flagged.</p></li>
<li><p><strong>window</strong> (<em>int</em><em>, </em><em>str</em>) – Size of the repetition window. An integer defines the exact number of repetitions,
strings are interpreted as time offsets to fill with .</p></li>
<li><p><strong>method</strong> (<em>{&quot;ffill&quot;</em><em>, </em><em>&quot;bfill&quot;}</em>) – Direction of repetetion. With “ffill” the subsequent values receive the flag to
repeat, with “bfill” the previous values.</p></li>
<li><p><strong>flag</strong> (<em>float</em><em>, </em><em>default BAD</em>) – Flag to set.</p></li>
<li><p><strong>dfilter</strong> (<em>float</em><em>, </em><em>default FILTER_ALL</em>) – Threshold flag.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>First, generate some data and some flags:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flags</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mf">255.0</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span> <span class="o">=</span> <span class="n">saqc</span><span class="o">.</span><span class="n">SaQC</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">]</span>
<span class="go">0     -inf</span>
<span class="go">1     -inf</span>
<span class="go">2     -inf</span>
<span class="go">3    255.0</span>
<span class="go">4     -inf</span>
<span class="go">5     -inf</span>
<span class="go">6     -inf</span>
<span class="go">Name: a, dtype: float64</span>
</pre></div>
</div>
<p>Now, to repeat the flag ‘255.0’ two times in direction of ascending indices, execute:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span><span class="o">.</span><span class="n">propagateFlags</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;ffill&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">]</span>
<span class="go">0     -inf</span>
<span class="go">1     -inf</span>
<span class="go">2     -inf</span>
<span class="go">3    255.0</span>
<span class="go">4    255.0</span>
<span class="go">5    255.0</span>
<span class="go">6     -inf</span>
<span class="go">Name: a, dtype: float64</span>
</pre></div>
</div>
<p>Choosing “bfill” will result in</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span><span class="o">.</span><span class="n">propagateFlags</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;bfill&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">]</span>
<span class="go">0     -inf</span>
<span class="go">1    255.0</span>
<span class="go">2    255.0</span>
<span class="go">3    255.0</span>
<span class="go">4     -inf</span>
<span class="go">5     -inf</span>
<span class="go">6     -inf</span>
<span class="go">Name: a, dtype: float64</span>
</pre></div>
</div>
<p>If an explicit flag is passed, it will be used to fill the repetition window
.. doctest:: propagateFlags</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span><span class="o">.</span><span class="n">propagateFlags</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;bfill&quot;</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="mi">111</span><span class="p">)</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">]</span>
<span class="go">0     -inf</span>
<span class="go">1    111.0</span>
<span class="go">2    111.0</span>
<span class="go">3    255.0</span>
<span class="go">4     -inf</span>
<span class="go">5     -inf</span>
<span class="go">6     -inf</span>
<span class="go">Name: a, dtype: float64</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.renameField">
<span class="sig-name descname"><span class="pre">renameField</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.renameField" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename field in data and flags.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> (<em>str</em>) – The fieldname of the data column, you want to rename.</p></li>
<li><p><strong>new_name</strong> (<em>str</em>) – String, field is to be replaced with.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.resample">
<span class="sig-name descname"><span class="pre">resample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func=&lt;function</span> <span class="pre">mean&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method='bagg'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxna=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxna_group=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxna_flags=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxna_group_flags=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag_func=&lt;built-in</span> <span class="pre">function</span> <span class="pre">max&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq_check=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.resample" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to resample the data.</p>
<p>The data will be sampled at regular (equidistant) timestamps aka. Grid points.
Sampling intervals therefore get aggregated with a function, specified by
‘func’ parameter and the result gets projected onto the new timestamps with a
method, specified by “method”. The following method (keywords) are available:</p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">'nagg'</span></code>: all values in the range (+/- <cite>freq</cite>/2) of a grid point get</dt><dd><p>aggregated with func and assigned to it.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">'bagg'</span></code>: all values in a sampling interval get aggregated with func and</dt><dd><p>the result gets assigned to the last grid point.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">'fagg'</span></code>: all values in a sampling interval get aggregated with func and</dt><dd><p>the result gets assigned to the next grid point.</p>
</dd>
</dl>
</li>
</ul>
<p>Note, that. if possible, functions passed to func will get projected
internally onto pandas.resample methods, wich results in some reasonable
performance boost - however, for this to work, you should pass functions that
have the __name__ attribute initialised and the according methods name assigned
to it. Furthermore, you shouldnt pass numpys nan-functions (<code class="docutils literal notranslate"><span class="pre">nansum</span></code>,
<code class="docutils literal notranslate"><span class="pre">nanmean</span></code>,…) because those for example, have <code class="docutils literal notranslate"><span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'nansum'</span></code> and
they will thus not trigger <code class="docutils literal notranslate"><span class="pre">resample.func()</span></code>, but the slower <code class="docutils literal notranslate"><span class="pre">resample.apply(</span>
<span class="pre">nanfunc)</span></code>. Also, internally, no nans get passed to the functions anyway,
so that there is no point in passing the nan functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>field</strong> (<em>str</em>) – The fieldname of the column, holding the data-to-be-resampled.</p>
</dd>
</dl>
<dl class="simple">
<dt>freq<span class="classifier">str</span></dt><dd><p>An Offset String, that will be interpreted as the frequency you want to
resample your data with.</p>
</dd>
<dt>func<span class="classifier">Callable</span></dt><dd><p>The function you want to use for aggregation.</p>
</dd>
<dt>method: {‘fagg’, ‘bagg’, ‘nagg’}, default ‘bagg’</dt><dd><p>Specifies which intervals to be aggregated for a certain timestamp. (preceding,
succeeding or “surrounding” interval). See description above for more details.</p>
</dd>
<dt>maxna<span class="classifier">{None, int}, default None</span></dt><dd><p>Maximum number NaNs in a resampling interval. If maxna is exceeded, the interval
is set entirely to NaN.</p>
</dd>
<dt>maxna_group<span class="classifier">{None, int}, default None</span></dt><dd><p>Same as <cite>maxna</cite> but for consecutive NaNs.</p>
</dd>
<dt>maxna_flags<span class="classifier">{None, int}, default None</span></dt><dd><p>Same as <cite>max_invalid</cite>, only applying for the flags. The flag regarded
as “invalid” value, is the one passed to empty_intervals_flag (
default=``BAD``). Also this is the flag assigned to invalid/empty intervals.</p>
</dd>
<dt>maxna_group_flags<span class="classifier">{None, int}, default None</span></dt><dd><p>Same as <cite>maxna_flags</cite>, only applying onto flags. The flag regarded as
“invalid” value, is the one passed to empty_intervals_flag. Also this is the
flag assigned to invalid/empty intervals.</p>
</dd>
<dt>flag_func<span class="classifier">Callable, default: max</span></dt><dd><p>The function you want to aggregate the flags with. It should be capable of
operating on the flags dtype (usually ordered categorical).</p>
</dd>
</dl>
<p>freq_check : {None, ‘check’, ‘auto’}, default None</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code>: do not validate frequency-string passed to <cite>freq</cite></p></li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">'check'</span></code>: estimate frequency and log a warning if estimate miss matchs</dt><dd><p>frequency string passed to ‘freq’, or if no uniform sampling rate could be
estimated</p>
</dd>
</dl>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">'auto'</span></code>: estimate frequency and use estimate. (Ignores <cite>freq</cite> parameter.)</p></li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.roll">
<span class="sig-name descname"><span class="pre">roll</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func=&lt;function</span> <span class="pre">mean&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_periods=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.roll" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate a rolling-window function on the data.</p>
<p>Note, that the data gets assigned the worst flag present in the original data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> (<em>str</em>) – The column to calculate on.</p></li>
<li><p><strong>window</strong> (<em>{int</em><em>, </em><em>str}</em>) – The size of the window you want to roll with. If an integer is passed, the size
refers to the number of periods for every fitting window. If an offset string
is passed, the size refers to the total temporal extension. For regularly
sampled timeseries, the period number will be casted down to an odd number if
<code class="docutils literal notranslate"><span class="pre">center=True</span></code>.</p></li>
<li><p><strong>func</strong> (<em>Callable</em><em>, </em><em>default np.mean</em>) – Function to roll with.</p></li>
<li><p><strong>min_periods</strong> (<em>int</em><em>, </em><em>default 0</em>) – The minimum number of periods to get a valid value</p></li>
<li><p><strong>center</strong> (<em>bool</em><em>, </em><em>default True</em>) – If True, center the rolling window.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.selectTime">
<span class="sig-name descname"><span class="pre">selectTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">selection_field</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">closed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.selectTime" title="Permalink to this definition">¶</a></dt>
<dd><p>Realizes masking within saqc.</p>
<p>Due to some inner saqc mechanics, it is not straight forwardly possible to exclude
values or datachunks from flagging routines. This function replaces flags with UNFLAGGED
value, wherever values are to get masked. Furthermore, the masked values get replaced by
np.nan, so that they dont effect calculations.</p>
<p>Here comes a recipe on how to apply a flagging function only on a masked chunk of the variable field:</p>
<ol class="arabic simple">
<li><p>dublicate “field” in the input data (<cite>copyField</cite>)</p></li>
<li><p>mask the dublicated data (this, <cite>selectTime</cite>)</p></li>
<li><p>apply the tests you only want to be applied onto the masked data chunks (a saqc function)</p></li>
<li><dl class="simple">
<dt>project the flags, calculated on the dublicated and masked data onto the original field data</dt><dd><p>(<cite>concateFlags</cite> or <cite>flagGeneric</cite>)</p>
</dd>
</dl>
</li>
<li><p>drop the dublicated data (<cite>dropField</cite>)</p></li>
</ol>
<p>To see an implemented example, checkout flagSeasonalRange in the saqc.functions module</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> (<em>str</em>) – The fieldname of the column, holding the data-to-be-masked.</p></li>
<li><p><strong>mode</strong> (<em>{&quot;periodic&quot;</em><em>, </em><em>&quot;mask_field&quot;}</em>) – The masking mode.
- “periodic”: parameters “period_start”, “end” are evaluated to generate a periodical mask
- “mask_var”: data[mask_var] is expected to be a boolean valued timeseries and is used as mask.</p></li>
<li><p><strong>selection_field</strong> (<em>{None</em><em>, </em><em>str}</em><em>, </em><em>default None</em>) – Only effective if mode == “mask_var”
Fieldname of the column, holding the data that is to be used as mask. (must be boolean series)
Neither the series` length nor its labels have to match data[field]`s index and length. An inner join of the
indices will be calculated and values get masked where the values of the inner join are <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p><strong>start</strong> (<em>{None</em><em>, </em><em>str}</em><em>, </em><em>default None</em>) – Only effective if mode == “seasonal”
String denoting starting point of every period. Formally, it has to be a truncated instance of “mm-ddTHH:MM:SS”.
Has to be of same length as <cite>end</cite> parameter.
See examples section below for some examples.</p></li>
<li><p><strong>end</strong> (<em>{None</em><em>, </em><em>str}</em><em>, </em><em>default None</em>) – Only effective if mode == “periodic”
String denoting starting point of every period. Formally, it has to be a truncated instance of “mm-ddTHH:MM:SS”.
Has to be of same length as <cite>end</cite> parameter.
See examples section below for some examples.</p></li>
<li><p><strong>closed</strong> (<em>boolean</em>) – Wheather or not to include the mask defining bounds to the mask.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>The <cite>period_start</cite> and <cite>end</cite> parameters provide a conveniant way to generate seasonal / date-periodic masks.
They have to be strings of the forms: “mm-ddTHH:MM:SS”, “ddTHH:MM:SS” , “HH:MM:SS”, “MM:SS” or “SS”
(mm=month, dd=day, HH=hour, MM=minute, SS=second)
Single digit specifications have to be given with leading zeros.
<cite>period_start</cite> and <cite>seas   on_end</cite> strings have to be of same length (refer to the same periodicity)
The highest date unit gives the period.
For example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">start</span> <span class="o">=</span> <span class="s2">&quot;01T15:00:00&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">end</span> <span class="o">=</span> <span class="s2">&quot;13T17:30:00&quot;</span>
</pre></div>
</div>
<p>Will result in all values sampled between 15:00 at the first and  17:30 at the 13th of every month get masked</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">start</span> <span class="o">=</span> <span class="s2">&quot;01:00&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">end</span> <span class="o">=</span> <span class="s2">&quot;04:00&quot;</span>
</pre></div>
</div>
<p>All the values between the first and 4th minute of every hour get masked.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">start</span> <span class="o">=</span> <span class="s2">&quot;01-01T00:00:00&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">end</span> <span class="o">=</span> <span class="s2">&quot;01-03T00:00:00&quot;</span>
</pre></div>
</div>
<p>Mask january and february of evcomprosed in theery year. masking is inclusive always, so in this case the mask will
include 00:00:00 at the first of march. To exclude this one, pass:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">start</span> <span class="o">=</span> <span class="s2">&quot;01-01T00:00:00&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">end</span> <span class="o">=</span> <span class="s2">&quot;02-28T23:59:59&quot;</span>
</pre></div>
</div>
<p>To mask intervals that lap over a seasons frame, like nights, or winter, exchange sequence of season start and
season end. For example, to mask night hours between 22:00:00 in the evening and 06:00:00 in the morning, pass:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">start</span> <span class="o">=</span> <span class="s2">&quot;22:00:00&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">end</span> <span class="o">=</span> <span class="s2">&quot;06:00:00&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.shift">
<span class="sig-name descname"><span class="pre">shift</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'nshift'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq_check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to shift data and flags to a regular (equidistant) timestamp grid, according to <code class="docutils literal notranslate"><span class="pre">method</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>field</strong> (<em>str</em>) – The fieldname of the column, holding the data-to-be-shifted.</p>
</dd>
</dl>
<dl class="simple">
<dt>freq<span class="classifier">str</span></dt><dd><p>An frequency Offset String that will be interpreted as the sampling rate you want the data to be shifted to.</p>
</dd>
<dt>method<span class="classifier">{‘fshift’, ‘bshift’, ‘nshift’}, default ‘nshift’</span></dt><dd><p>Specifies how misaligned data-points get propagated to a grid timestamp.
Following choices are available:</p>
<ul class="simple">
<li><p>‘nshift’ : every grid point gets assigned the nearest value in its range. (range = +/- 0.5 * <cite>freq</cite>)</p></li>
<li><p>‘bshift’ : every grid point gets assigned its first succeeding value, if one is available in
the succeeding sampling interval.</p></li>
<li><p>‘fshift’ : every grid point gets assigned its ultimately preceding value, if one is available in
the preceeding sampling interval.</p></li>
</ul>
</dd>
</dl>
<p>freq_check : {None, ‘check’, ‘auto’}, default None</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> : do not validate frequency-string passed to <cite>freq</cite></p></li>
<li><p>‘check’ : estimate frequency and log a warning if estimate miss matches frequency string passed to <cite>freq</cite>,
or if no uniform sampling rate could be estimated</p></li>
<li><p>‘auto’ : estimate frequency and use estimate. (Ignores <cite>freq</cite> parameter.)</p></li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.transferFlags">
<span class="sig-name descname"><span class="pre">transferFlags</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.transferFlags" title="Permalink to this definition">¶</a></dt>
<dd><p>Transfer Flags of one variable to another.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>field</strong> (<em>str</em><em> or </em><em>List of str</em>) – Variable or list of variables, the flags of which are to be transferred.</p>
</dd>
</dl>
<dl class="simple">
<dt>target<span class="classifier">str or List of str</span></dt><dd><p>Variable or list of variables, the flags of <cite>field</cite> are to be transferred to.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>First, generate some data with some flags:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span> <span class="o">=</span> <span class="n">saqc</span><span class="o">.</span><span class="n">SaQC</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">flagRange</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">to_df</span><span class="p">()</span>
<span class="go">columns      a    b    c</span>
<span class="go">0         -inf -inf -inf</span>
<span class="go">1        255.0 -inf -inf</span>
</pre></div>
</div>
<p>Now we can project the flag from <cite>a</cite> to <cite>b</cite> via</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">transferFlags</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">to_df</span><span class="p">()</span>
<span class="go">columns      a      b    c</span>
<span class="go">0         -inf   -inf -inf</span>
<span class="go">1        255.0  255.0 -inf</span>
</pre></div>
</div>
<p>You can skip the explicit target parameter designation:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">transferFlags</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>To project the flags of <cite>a</cite> to both the variables <cite>b</cite> and <cite>c</cite> in one call, align the field and target variables in
2 lists:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">transferFlags</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">to_df</span><span class="p">()</span>
<span class="go">columns      a      b      c</span>
<span class="go">0         -inf   -inf   -inf</span>
<span class="go">1        255.0  255.0  255.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="saqc.SaQC.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#saqc.SaQC.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to transform data columns with a transformation that maps series onto series of the same length.</p>
<p>Note, that flags get preserved.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> (<em>str</em>) – The fieldname of the column, holding the data-to-be-transformed.</p></li>
<li><p><strong>func</strong> (<em>Callable</em><em>[</em><em>{pd.Series</em><em>, </em><em>np.array}</em><em>, </em><em>np.array</em><em>]</em>) – Function to transform data[field] with.</p></li>
<li><p><strong>freq</strong> (<em>{None</em><em>, </em><em>float</em><em>, </em><em>str}</em><em>, </em><em>default None</em>) – <p>Determines the segmentation of the data into partitions, the transformation is applied on individually</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">np.inf</span></code>: Apply transformation on whole data set at once</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> &gt; 0 : Apply transformation on successive data chunks of periods length <code class="docutils literal notranslate"><span class="pre">x</span></code></p></li>
<li><p>Offset String : Apply transformation on successive partitions of temporal extension matching the passed offset
string</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – An <a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saqc.SaQC()</span></code></a> object, holding the (possibly) modified data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#saqc.SaQC" title="saqc.SaQC">saqc.SaQC</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/SaQCLogo.png" alt="Logo"/>
            </a></p>
  <div>
    <h3><a href="../index.html">Table of Contents</a></h3>
    <ul>
<li class="toctree-l1"><a class="reference external" href="https://git.ufz.de/rdm-software/saqc">Repository</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../gettingstarted/InstallationGuide.html">Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gettingstarted/TutorialAPI.html">Python API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gettingstarted/TutorialCLI.html">Command Line Application</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Cookbooks</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../cookbooks/DataRegularisation.html">Data Regularisation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cookbooks/OutlierDetection.html">Outlier Detection and Flagging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cookbooks/MultivariateFlagging.html">Multivariate Flagging</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../documentation/ConfigurationFiles.html">Configuration Files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../documentation/GenericFunctions.html">Generic Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../documentation/GlobalKeywords.html">Global Keywords</a></li>
<li class="toctree-l1"><a class="reference internal" href="../documentation/Customizations.html">Customizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../documentation/SourceTarget.html">Assigning results to new variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../documentation/FlaggingTranslation.html">Flags, History and Translations</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">SaQC</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../modules/SaQC.html">Package</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../modules/SaQC.html#module-saqc">saqc Package</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../modules/SaQC.html#functions">Functions</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../modules/SaQC.html#classes">Classes</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="saqc.Flags.html">Flags</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">SaQC</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../modules/SaQCCore.html">Core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/SaQCFunctions.html">Test Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/SaQCTranslation.html">Translations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/SaQCConstants.html">Constants</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Resources</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../howtodoc/HowToDoc.html">Documentation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../documentation/WritingFunctions.html">Writing Functions</a></li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="saqc.Flags.html"
                          title="previous chapter">Flags</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="../modules/SaQCCore.html"
                          title="next chapter">SaQC</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/_api/saqc.SaQC.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../modules/SaQCCore.html" title="SaQC"
             >next</a> |</li>
        <li class="right" >
          <a href="saqc.Flags.html" title="Flags"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">SaQC 2.0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../modules/SaQC.html" >SaQC</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">SaQC</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, Bert Palm, David Schäfer, Peter Lünenschloß, Florian Gransee.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>
  </body>
</html>